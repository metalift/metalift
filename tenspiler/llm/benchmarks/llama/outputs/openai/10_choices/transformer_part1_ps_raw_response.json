{"transformer_part1": ["\ndef transformer_part1(\n    token_position: int,\n    head: int,\n    head_size: int,\n    key_cache_layer: List[List[int]],\n    q: List[int]\n) -> List[int]:\n    return matrix_vec_mul(\n        matrix_col_slice(\n            matrix_scalar_div(\n                integer_sqrt(head_size),\n                matrix_row_slice(\n                    matrix_scalar_mul(\n                        head_size,\n                        matrix_transpose(key_cache_layer)\n                    ),\n                    head * head_size,\n                    (head + 1) * head_size\n                )\n            ),\n            0,\n            token_position\n        ),\n        q\n    )\n", "\ndef transformer_part1(\n    token_position: int,\n    head: int,\n    head_size: int,\n    key_cache_layer: List[List[int]],\n    q: List[int]\n) -> List[int]:\n    return (\n        []\n        if token_position <= 0\n        else [\n            reduce_sum(\n                vec_elemwise_mul(\n                    vec_slice(q, head * head_size, (head + 1) * head_size),\n                    key_cache_layer[token_position - 1][head * head_size : (head + 1) * head_size]\n                )\n            ) // integer_sqrt(head_size)\n        ] + transformer_part1(token_position - 1, head, head_size, key_cache_layer, q)\n    )\n", "\ndef transformer_part1(\n    token_position: int,\n    head: int,\n    head_size: int,\n    key_cache_layer: List[List[int]],\n    q: List[int]\n) -> List[int]:\n    return matrix_vec_mul(\n        matrix_row_slice(\n            matrix_scalar_div(\n                head_size, \n                matrix_scalar_mul(\n                    head, \n                    matrix_col_slice(key_cache_layer, 0, token_position)\n                )\n            ), \n            0, \n            token_position\n        ), \n        vec_slice(q, head * head_size, (head + 1) * head_size)\n    )\n", "\ndef transformer_part1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> List[int]:\n    return matrix_vec_mul(matrix_row_slice(key_cache_layer, 0, token_position), vec_slice(q, head * head_size, (head + 1) * head_size))\n", "\ndef transformer_part1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> List[int]:\n    return matrix_vec_mul(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, token_position), head * head_size, (head + 1) * head_size), vec_scalar_div(integer_sqrt(head_size), vec_slice(q, head * head_size, (head + 1) * head_size)))\n", "\ndef transformer_part1(token_position, head, head_size, key_cache_layer, q):\n    return matrix_vec_mul(\n                matrix_row_slice(\n                    matrix_scalar_div(\n                        integer_sqrt(head_size), \n                        matrix_scalar_mul(head_size, key_cache_layer)\n                    ), \n                    0, token_position\n                ), \n                vec_slice(q, head * head_size, (head + 1) * head_size)\n           )\n", "\ndef transformer_part1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> List[int]:\n    return matrix_vec_mul(matrix_row_slice(key_cache_layer, 0, token_position), vec_scalar_div(integer_sqrt(head_size * 1), vec_slice(q, head * head_size, (head + 1) * head_size)))\n", "\ndef transformer_part1(token_position, head, head_size, key_cache_layer, q):\n    return matrix_vec_mul(matrix_row_slice(matrix_col_slice(key_cache_layer, head * head_size, (head + 1) * head_size), 0, token_position), vec_slice(q, head * head_size, (head + 1) * head_size))\n", "\ndef transformer_part1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> List[int]:\n    return matrix_vec_mul(\n        matrix_scalar_div(\n            integer_sqrt(head_size), \n            matrix_row_slice(key_cache_layer, 0, token_position)\n        ), \n        vec_slice(q, head * head_size, (head + 1) * head_size)\n    )\n", "\ndef transformer_part1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> List[int]:\n    return matrix_vec_mul(matrix_row_slice(key_cache_layer, 0, token_position), vec_scalar_div(integer_sqrt(head_size), vec_slice(q, head * head_size, (head + 1) * head_size)))\n"]}
