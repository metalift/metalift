{"softmax_part2": ["\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_slice(input, 0, max_pos), lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_slice(input, 0, i), lambda x: integer_exp(x - max_val))\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_elemwise_sub(integer_exp(vec_slice(input, 0, max_pos)), [max_val]*max_pos)\n\n\n\ndef invariant1(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_elemwise_sub(integer_exp(vec_slice(input, 0, i)), [max_val]*i)\n", "\n#Rewritten function\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(input[:max_pos], lambda x: integer_exp(x - max_val))\n\n#Invariant\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(input[:i], lambda x: integer_exp(x - max_val))\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_slice(input, 0, max_pos), lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_slice(input, 0, i), lambda x: integer_exp(x - max_val))\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(input[:max_pos], lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(cur: int, i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(input[:i], lambda x: integer_exp(x - max_val))\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(input[:max_pos], lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(input[:i], lambda x: integer_exp(x - max_val))\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_slice(input, 0, max_pos), lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant1(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_slice(input, 0, i), lambda x: integer_exp(x - max_val))\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(input[:max_pos], lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(input[:i], lambda x: integer_exp(x - max_val))\n", "\nfrom typing import List\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_elemwise_sub(input[:max_pos], [max_val]*max_pos), integer_exp)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_elemwise_sub(input[:i], [max_val]*i), integer_exp)\n", "\ndef softmax_part2(input: list[int], max_pos: int, max_val: int) -> list[int]:\n    return vec_map(input[:max_pos], lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(i: int, input: list[int], max_pos: int, max_val: int, output: list[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(input[:i], lambda x: integer_exp(x - max_val))\n"]}
