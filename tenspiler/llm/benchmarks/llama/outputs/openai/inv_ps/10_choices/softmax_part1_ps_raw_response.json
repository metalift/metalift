{"softmax_part1": ["\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_val: int) -> bool:\n    return i >= 0 and i <= len(input) and max_val == reduce_max(input[:i])\n", "\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n", "\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n", "\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n", "\n#defined functions\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][start:]\n\ndef test(input: List[int], max_pos: int) -> int:\n    return reduce_max(vec_slice(input, 0, max_pos))\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int) -> bool:\n    return i >= 1 and i <= max_pos and max_val == reduce_max(vec_slice(input, 0, i))\n", "\n#defined functions\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][start:]\n\n#test function\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(vec_slice(input, 0, max_pos))\n\n#loop invariant\ndef invariant(i: int, input: List[int], max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(vec_slice(input, 0, i))\n", "\nfrom typing import List\n\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n", "\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n", "\n#rewritten function\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n#loop invariant\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n", "\ndef softmax_part1(input: List[int], max_pos: int) -> int:\n    return reduce_max(input[:max_pos])\n\n\n\ndef invariant(i: int, input: List[int], max_val: int) -> bool:\n    return i >= 0 and i <= max_pos and max_val == reduce_max(input[:i])\n"]}
