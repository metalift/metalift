["\nfrom typing import List\n\ndef vec_color_dodge(x: List[int], y: List[int]) -> List[int]:\n    return [32 if y[i] == 32 else x[i]//(32-y[i]) for i in range(len(x))]\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [vec_color_dodge(base[i], active[i]) for i in range(len(base))]\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], i: int) -> bool:\n    return all(out[j] == vec_color_dodge(base[j], active[j]) for j in range(i))\n\n\n\ndef invariant2(base: List[List[int]], active: List[List[int]], out: List[List[int]], i: int, j: int) -> bool:\n    return all(out[i][k] == (32 if active[i][k] == 32 else base[i][k]//(32-active[i][k])) for k in range(j))\n", "\nfrom typing import List\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, \n                        matrix_elemwise_div(base, matrix_scalar_sub(32, active)), \n                        lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(active[:row], \n                                                                 matrix_elemwise_div(base[:row], \n                                                                 matrix_scalar_sub(32, active[:row])), \n                                                                 lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, out: List[List[int]], row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(active[row][:col], \n                                                                                                         vec_elemwise_div(base[row][:col], \n                                                                                                                          vec_scalar_sub(32, active[row][:col])), \n                                                                                                         lambda x, y: 32 if x == 32 else y)\n", "\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, matrix_elemwise_div(base, scalar_matrix_sub(32, active)), lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row < len(base) and out[:row] == matrix_where(active[:row], matrix_elemwise_div(base[:row], scalar_matrix_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int, col: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col < len(base[row]) and row >= 0 and row < len(base) and row_vec == vector_where(active[row][:col], vec_elemwise_div(base[row][:col], vec_scalar_sub(32, active[row][:col])), lambda x, y: 32 if x == 32 else y)\n", "\nfrom typing import List\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def pixel_dodge(b:int, a:int) -> int:\n        return 32 if a == 32 else b//(32 - a)\n    \n    return matrix_where(active, base, pixel_dodge)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    def pixel_dodge(b:int, a:int) -> int:\n        return 32 if a == 32 else b//(32 - a)\n    \n    return row >= 0 and row <= len(base) and out[:row] == matrix_where(active[:row], base[:row], pixel_dodge)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int, col: int, row_vec: List[int]) -> bool:\n    def pixel_dodge(b:int, a:int) -> int:\n        return 32 if a == 32 else b//(32 - a)\n    \n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec[:col] == vector_where(active[row][:col], base[row][:col], pixel_dodge) and out[:row] == matrix_where(active[:row], base[:row], pixel_dodge)\n", "\nfrom typing import Callable, List\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, matrix_elemwise_div(base, scalar_matrix_sub(32, active)), lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(active[:row], matrix_elemwise_div(base[:row], scalar_matrix_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, out: List[List[int]], row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(active[row][:col], vec_elemwise_div(base[row][:col], vec_scalar_sub(32, active[row][:col])), lambda x, y: 32 if x == 32 else y) and out == matrix_where(active[:row], matrix_elemwise_div(base[:row], scalar_matrix_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n", "\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, matrix_elemwise_div(base, matrix_scalar_sub(32, active)), lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(active[:row], matrix_elemwise_div(base[:row], matrix_scalar_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, out: List[List[int]], row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(active[row][:col], vec_elemwise_div(base[row][:col], vec_scalar_sub(32, active[row][:col])), lambda x, y: 32 if x == 32 else y) and out == matrix_where(active[:row], matrix_elemwise_div(base[:row], matrix_scalar_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n", "\nfrom typing import List\n\ndef matrix_elemwise_conditional_div(base: List[List[int]], active: List[List[int]], scalar: int) -> List[List[int]]:\n    return matrix_where(active, \n                        matrix_elemwise_div(base, matrix_scalar_sub(scalar, active)), \n                        lambda x, y: scalar if x == scalar else y)\n\n\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_elemwise_conditional_div(base, active, 32)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out[:row] == matrix_elemwise_conditional_div(base[:row], active[:row], 32)\n\n\n\ndef invariant2(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int, col: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row_vec[:col] == vector_where(active[row][:col], vec_elemwise_div(base[row][:col], vec_scalar_sub(32, active[row][:col])), lambda x, y: 32 if x == 32 else y)\n", "I apologize for the misunderstanding in the previous answers. In order to properly assist you, I need to ask for clarification. You've provided a C++ function and asked for it to be rewritten using a set of provided functions and constants. However, no specific set of functions or constants were provided in your question. \n\nThe C++ function you've provided applies the \"Color Dodge\" blend mode to two images represented as 2D arrays. Each pixel in the base layer is divided by the inverse of the corresponding pixel in the active layer. \n\nCould you please specify the set of functions and constants you want this C++ function to be rewritten with? Also, are you asking for the rewritten function to be in C++ or in another language like Python? \n\nMoreover, you mentioned \"loop invariants.\" Loop invariants are conditions that remain unchanged throughout each iteration of a loop. They are used to prove the correctness of algorithms. If you need loop invariants for the provided function, could you please specify what properties or conditions should the invariants capture or maintain? \n\nThank you in advance for your clarification!", "\nfrom typing import List\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, matrix_elemwise_div(base, matrix_scalar_sub(32, active)), lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row < len(base) and out[:row] == matrix_where(active[:row], matrix_elemwise_div(base[:row], matrix_scalar_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant2(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int, col: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col < len(base[0]) and row >= 0 and row < len(base) and row_vec[:col] == vector_where(active[row][:col], vec_elemwise_div(base[row][:col], vec_scalar_sub(32, active[row][:col])), lambda x, y: 32 if x == 32 else y)\n", "\nfrom typing import List\n\ndef color_dodge_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, matrix_elemwise_div(base, matrix_scalar_sub(32, active)), lambda x, y: 32 if x == 32 else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(active[:row], matrix_elemwise_div(base[:row], matrix_scalar_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, out: List[List[int]], row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(active[row][:col], vec_elemwise_div(base[row][:col], vec_scalar_sub(32, active[row][:col])), lambda x, y: 32 if x == 32 else y) and out == matrix_where(active[:row], matrix_elemwise_div(base[:row], matrix_scalar_sub(32, active[:row])), lambda x, y: 32 if x == 32 else y)\n"]
