["\ndef lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, lambda x, y: x if x > y else y)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int, row_vec: List[int], col: int) -> bool:\n    return row >= 0 and row < len(base) and col >= 0 and col <= len(base[0]) and row_vec == vector_where(base[row][:col], active[row][:col], lambda x, y: x if x > y else y) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n", "\ndef lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, max)\n\n\n\nfrom typing import List\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], max)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, out: List[List[int]], row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(base[row][:col], active[row][:col], max) and out == matrix_where(base[:row], active[:row], max)\n", "\nfrom typing import List, Callable\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\ndef test(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, max)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], max)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int, row_vec: List[int], col: int) -> bool:\n    return row >= 0 and row < len(base) and col >= 0 and col <= len(base[0]) and row_vec == vector_where(base[row][:col], active[row][:col], max) and out == matrix_where(base[:row], active[:row], max)\n", "\nfrom typing import List\nfrom operator import gt\n\ndef lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, lambda x, y: x if gt(x, y) else y)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], lambda x, y: x if gt(x, y) else y)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int, row_vec: List[int], col: int) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(base[row][:col], active[row][:col], lambda x, y: x if gt(x, y) else y) and out == matrix_where(base[:row], active[:row], lambda x, y: x if gt(x, y) else y)\n", "In Example2, the `test` function can be rewritten as follows:\n\n    #rewritten function\n    def lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n        return matrix_where(base, active, max)\n\nThe `lighten_blend_8` function returns a matrix which is the result of applying the `max` function elementwise to the matrices `base` and `active`. The `max` function returns the maximum of its two arguments. Thus, for every corresponding pair of elements in `base` and `active`, the larger element is selected.\n\nNow, let us define the loop invariants:\n\n    #loop invariants\n    def invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n        return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], max)\n\n    def invariant2(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int, col: int, row_vec: List[int]) -> bool:\n        return row >= 0 and row < len(base) and col >= 0 and col <= len(base[0]) and row_vec == vector_where(base[row][:col], active[row][:col], max) and out == matrix_where(base[:row], active[:row], max)\n\nThe `invariant1` function checks that the row index is within valid bounds and that the `out` matrix is the result of applying the `max` function elementwise to the first `row` rows of `base` and `active`.\n\nThe `invariant2` function checks that the row and column indices are within valid bounds, that `row_vec` is the result of applying the `max` function elementwise to the first `col` elements of the current row of `base` and `active`, and that `out` is still the result of applying the `max` function elementwise to the first `row` rows of `base` and `active`.", "\ndef lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, max)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], max)\n\n\n\ndef invariant2(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int, col: int) -> bool:\n    return col >= 0 and col <= len(base[0]) and out[row][:col] == vector_where(base[row][:col], active[row][:col], max)\n", "\ndef lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, lambda x, y: x if x > y else y)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, out: List[List[int]], row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(base[row][:col], active[row][:col], lambda x, y: x if x > y else y) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n", "\ndef lighten_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, active, max)\n\n\n\ndef invariant1(row: int, base: List[List[int]], active: List[List[int]], out: List[List[int]]) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], max)\n\ndef invariant2(row: int, col: int, base: List[List[int]], active: List[List[int]], out: List[List[int]], row_vec: List[int]) -> bool:\n    return row >= 0 and row < len(base) and col >= 0 and col <= len(base[0]) and row_vec == vector_where(base[row][:col], active[row][:col], max) and out == matrix_where(base[:row], active[:row], max)\n", "\ndef lighten_blend_8(base: list[list[int]], active: list[list[int]]) -> list[list[int]]:\n    return matrix_where(base, active, lambda x, y: x if x > y else y)\n\n\n\ndef invariant1(base: list[list[int]], active: list[list[int]], out: list[list[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n\ndef invariant2(base: list[list[int]], active: list[list[int]], out: list[list[int]], row: int, row_vec: list[int], col: int) -> bool:\n    return row >= 0 and row < len(base) and col >= 0 and col <= len(base[0]) and row_vec == vector_where(base[row][:col], active[row][:col], lambda x, y: x if x > y else y) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n", "\ndef lighten_blend_8(base, active):\n    return matrix_where(base, active, lambda x, y: x if x > y else y)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], lambda x, y: x if x > y else y)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], row_vec: List[int], row: int, col: int) -> bool:\n    return row >= 0 and row < len(base) and col >= 0 and col <= len(base[0]) and row_vec == vector_where(base[row][:col], active[row][:col], lambda x, y: x if x > y else y)\n"]
