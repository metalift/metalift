["\nfrom typing import List\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_elemwise_add(\n        matrix_scalar_mul(32, matrix_where(matrix_elemwise_eq(active, 0), base, active)),\n        matrix_elemwise_sub(matrix_scalar_mul(32, base), matrix_elemwise_mul(base, active))\n    )\n", "I apologize for the confusion. It seems like there was some misunderstanding in your request. I'm providing a new version of the function and its invariants below:\n\n```python\n# Function Rewrite\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def pixel_burn(b: int, a: int) -> int:\n        return 32 if a == 0 else min(32, 32 - (32 - b) / a)\n    \n    return [[pixel_burn(b, a) for b, a in zip(base_row, active_row)] for base_row, active_row in zip(base, active)]\n\n# Invariants\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row < len(base) and out[:row] == color_burn_8(base[:row], active[:row", "Apologies for the confusion earlier. Here is the correct transformation of your function using provided functions:\n\n```python\nfrom typing import Callable, List\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], bool],\n    true_val: int,\n    false_val: Callable[[int, int], int]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition, true_val, false_val),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition, true_val, false_val),\n        ]\n    )\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], bool], true_val: int, false_val: Callable[[int, int], int]\n", "\ndef safe_div(x: List[List[int]], y: List[List[int]]) -> List[List[int]]:\n    return matrix_where(y, x, lambda y_val, x_val: 32 if y_val == 0 else x_val // y_val)\n", "\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return []\n\ndef matrix_elemwise_sub(matrix_x: List[List[int]], matrix_y: List[List[int]]) -> List[List[int]]:\n    return []\n\ndef matrix_scalar_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return []\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return []\n\ndef matrix_where(matrix_x: List[List[int]], matrix_y: List[List[int]], condition: Callable[[int, int], int]) -> List[List[int]]:\n    return []\n", "Apologies for the confusion. Let's generate a different program:\n\n```Python\nfrom typing import List\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(\n        active,\n        base,\n        lambda active_val, base_val: 32 if active_val == 0 else 32 - ((32 - base_val) // active_val)\n    )\n\ndef invariant1(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int) -> bool:\n    return row >= 0 and row <= len(base) and out[:row] == color_burn_8(base[:row], active[:row])\n\ndef invariant2(base: List[List[int]], active: List[List[int]], out: List[List[int]], row: int, row_vec: List[int], col: int) -> bool:\n    return col >= 0 and col <= len(base[0]) and row", "Apologies for the confusion earlier. Here is the correct transformation of the `color_burn_8` function and its invariants:\n\n```python\nfrom typing import List\n\n# Defined function for where operation\ndef vec_where(x: List[int], y: List[int], condition: Callable[[int, int], int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or len(y) < 1\n        else [condition(x[0], y[0]), *vec_where(x[1:], y[1:], condition)]\n    )\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_where(matrix_x[0], matrix_y[0], condition),\n            *matrix", "\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, base, lambda active_val, base_val: 32 if active_val == 0 else 32 - (32 - base_val) // active_val)\n", "\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, base, lambda a, b: 32 if a == 0 else 32 - (32 - b) // a)\n", "\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(active, base, lambda active_val, base_val: 32 if active_val == 0 else 32 - (32 - base_val) // active_val)\n"]
