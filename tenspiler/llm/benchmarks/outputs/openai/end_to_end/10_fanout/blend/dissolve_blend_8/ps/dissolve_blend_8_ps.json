["\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(\n        active,\n        base,\n        lambda x, y: x if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else y\n    )\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return (\n        row >= 0 and \n        row <= len(base) and \n        out == matrix_where(\n            active[:row],\n            base[:row],\n            lambda x, y: x if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else y\n        )\n    )\n\ndef invariant2(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int, col: int, row_vec: List[int]) -> bool:\n    return (\n        row >= 0 and \n        row < len(base) and \n        col >= 0 and \n        col <= len(base[0]) and \n        row_vec == vector_where(\n            active[row][:col],\n            base[row][:col],\n            lambda x, y: x if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else y\n        ) and \n        out == matrix_where(\n            active[:row],\n            base[:row],\n            lambda x, y: x if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else y\n        )\n    )\n", "\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(\n        active,\n        base,\n        lambda active_val, base_val: ite(\n            opacity - integer_sqrt(reduce_sum(integer_exp(rand_cons % 100) + 1)) / 100 >= 0,\n            active_val,\n            base_val,\n        ),\n    )\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= m and out == matrix_where(\n        active[:row],\n        base[:row],\n        lambda active_val, base_val: ite(\n            opacity - integer_sqrt(reduce_sum(integer_exp(rand_cons % 100) + 1)) / 100 >= 0,\n            active_val,\n            base_val,\n        ),\n    )\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= n and row >= 0 and row <= m and row_vec == col_vec(\n        matrix_where(\n            active[row][:col],\n            base[row][:col],\n            lambda active_val, base_val: ite(\n                opacity - integer_sqrt(reduce_sum(integer_exp(rand_cons % 100) + 1)) / 100 >= 0,\n                active_val,\n                base_val,\n            ),\n        ),\n        col,\n    ) and out == matrix_where(\n        active[:row],\n        base[:row],\n        lambda active_val, base_val: ite(\n            opacity - integer_sqrt(reduce_sum(integer_exp(rand_cons % 100) + 1)) / 100 >= 0,\n            active_val,\n            base_val,\n        ),\n    )\n", "\nfrom typing import List, Callable\n\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    def pixel_decision(base_val: int, active_val: int) -> int:\n        rand_val = ((rand_cons % 100) + 1) / 100\n        return ite(opacity - rand_val >= 0, active_val, base_val)\n\n    return matrix_where(base, active, pixel_decision)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(base[:row], active[:row], pixel_decision)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int], col: int) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(base[row][:col], active[row][:col], pixel_decision) and out == matrix_where(base[:row], active[:row], pixel_decision)\n", "\nfrom typing import List\n\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(active, base, lambda x, y: (rand_cons % 100 + 1) / 100 <= opacity)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(active[:row], base[:row], lambda x, y: (rand_cons % 100 + 1) / 100 <= opacity)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int], col: int) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(active[row][:col], base[row][:col], lambda x, y: (rand_cons % 100 + 1) / 100 <= opacity) and out == matrix_where(active[:row], base[:row], lambda x, y: (rand_cons % 100 + 1) / 100 <= opacity)\n", "\ndef dissolve_blend_8(base, active, opacity, rand_val):\n    condition = lambda x, y: opacity - rand_val >= 0\n    return matrix_where(active, base, condition)\n\n\n\ndef invariant1(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_val: int, row: int) -> bool:\n    condition = lambda x, y: opacity - rand_val >= 0\n    return row >= 0 and row <= base.size() and out == matrix_where(active[:row], base[:row], condition)\n\ndef invariant2(base: List[List[int]], active: List[List[int]], opacity: int, out: List[List[int]], rand_val: int, row: int, col: int) -> bool:\n    condition = lambda x, y: opacity - rand_val >= 0\n    return row >= 0 and row < base.size() and col >= 0 and col <= base[0].size() and out[row][col] == condition(active[row][col], base[row][col])\n", "\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(active, base, lambda x, y: opacity - ((rand_cons % 100) + 1) / 100 >= 0)\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(active[:row], base[:row], lambda x, y: opacity - ((rand_cons % 100) + 1) / 100 >= 0)\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row_vec == vector_where(active[row][:col], base[row][:col], lambda x, y: opacity - ((rand_cons % 100) + 1) / 100 >= 0) and out == matrix_where(active[:row], base[:row], lambda x, y: opacity - ((rand_cons % 100) + 1) / 100 >= 0)\n", "\nfrom typing import Callable, List\n\ndef vector_where(x: List[int], y: List[int], condition: Callable[[int, int], int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef matrix_where(matrix_x: List[List[int]], matrix_y: List[List[int]], condition: Callable[[int, int], int]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\ndef constant_matrix(m: int, n: int, value: int) -> List[List[int]]:\n    return [[value for _ in range(n)] for _ in range(m)]\n\n\n\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    m = len(base)\n    n = len(base[0])\n    rand_matrix = constant_matrix(m, n, ((rand_cons % 100) + 1) / 100)\n    condition = lambda x, y: x if opacity - y >= 0 else y\n    return matrix_where(active, matrix_where(base, rand_matrix, condition), condition)\n\n\n\ndef invariant1(row: int, m: int, base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int, out: List[List[int]]) -> bool:\n    rand_matrix = constant_matrix(row, len(base[0]), ((rand_cons % 100) + 1) / 100)\n    condition = lambda x, y: x if opacity - y >= 0 else y\n    return row >= 0 and row <= m and out[:row] == matrix_where(active[:row], matrix_where(base[:row], rand_matrix, condition), condition)\n\ndef invariant2(row: int, col: int, m: int, n: int, base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int, out: List[List[int]], row_vec: List[int]) -> bool:\n    rand_vector = constant_matrix(1, col, ((rand_cons % 100) + 1) / 100)[0]\n    condition = lambda x, y: x if opacity - y >= 0 else y\n    return row >= 0 and row < m and col >= 0 and col <= n and row_vec == vector_where(active[row][:col], vector_where(base[row][:col], rand_vector, condition), condition) and out[:row] == matrix_where(active[:row], matrix_where(base[:row], constant_matrix(row, n, ((rand_cons % 100) + 1) / 100), condition), condition)\n", "\nfrom typing import Callable, List\n\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(\n        active,\n        base,\n        lambda a, b: a if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else b\n    )\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(\n        active[:row],\n        base[:row],\n        lambda a, b: a if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else b\n    )\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(\n        active[row][:col],\n        base[row][:col],\n        lambda a, b: a if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else b\n    ) and out == matrix_where(\n        active[:row],\n        base[:row],\n        lambda a, b: a if opacity - ((rand_cons % 100) + 1) / 100 >= 0 else b\n    )\n", "\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(\n        active,\n        base,\n        lambda active_pixel, base_pixel: ((opacity - ((rand_cons % 100) + 1) / 100) >= 0)\n    )\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= len(base) and out == matrix_where(\n        active[:row],\n        base[:row],\n        lambda active_pixel, base_pixel: ((opacity - ((rand_cons % 100) + 1) / 100) >= 0)\n    )\n\ndef invariant2(active: List[List[int]], base: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int], col: int) -> bool:\n    return col >= 0 and col <= len(base[0]) and row >= 0 and row < len(base) and row_vec == vector_where(\n        active[row][:col],\n        base[row][:col],\n        lambda active_pixel, base_pixel: ((opacity - ((rand_cons % 100) + 1) / 100) >= 0)\n    ) and out == matrix_where(\n        active[:row],\n        base[:row],\n        lambda active_pixel, base_pixel: ((opacity - ((rand_cons % 100) + 1) / 100) >= 0)\n    )\n", "\ndef dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:\n    return matrix_where(active, base, lambda x, y: ite(opacity - ((rand_cons % 100) + 1) / 100 >= 0, x, y))\n\n\n\ndef invariant1(active: List[List[int]], base: List[List[int]], opacity: int, out: List[List[int]], rand_cons: int, row: int) -> bool:\n    return row >= 0 and row <= m and out == matrix_where(base[:row], active[:row], lambda x, y: ite(opacity - ((rand_cons % 100) + 1) / 100 >= 0, x, y))\n\ndef invariant2(active: List[List[int]], base: List[List[int]], col: int, opacity: int, out: List[List[int]], rand_cons: int, row: int, row_vec: List[int]) -> bool:\n    return col >= 0 and col < n and row_vec == vector_where(base[row][:col], active[row][:col], lambda x, y: ite(opacity - ((rand_cons % 100) + 1) / 100 >= 0, x, y)) and out == matrix_where(base[:row], active[:row], lambda x, y: ite(opacity - ((rand_cons % 100) + 1) / 100 >= 0, x, y))\n"]
