["\ndef invariant1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, attention: List[int]) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\ndef invariant2(token_position: int, head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int, attention: List[int]) -> bool:\n    return i >= 0 and i < head_size and timestep >= 0 and timestep <= token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), key_cache_layer[timestep])) // integer_sqrt(head_size) and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n", "\ndef invariant1(timestep: int, token_position: int, attention: List[int], head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul(\n        matrix_row_slice(\n            matrix_scalar_div(\n                integer_sqrt(head_size),\n                matrix_col_slice(\n                    key_cache_layer,\n                    head * head_size,\n                    (head + 1) * head_size\n                )\n            ),\n            0,\n            timestep\n        ),\n        vec_slice(q, head * head_size, (head + 1) * head_size)\n    )\n\ndef invariant2(i: int, timestep: int, token_position: int, score: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int]) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(\n        vec_elemwise_mul(\n            vec_slice(q, head * head_size, (head + 1) * head_size),\n            vec_slice(key_cache_layer[timestep], head * head_size, (head + 1) * head_size)\n        )\n    ) // integer_sqrt(head_size)\n", "\n# Loop invariant for outer loop\ndef invariant1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, attention: List[int]) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\n# Loop invariant for inner loop\ndef invariant2(token_position: int, head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int, attention: List[int]) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), vec_slice(key_cache_layer[timestep], head*head_size, (head + 1)*head_size))) and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size))\n", "\nfrom typing import List\n\ndef invariant1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, attention: List[int]) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul(matrix_row_slice(matrix_scalar_div(integer_sqrt(head_size), matrix_col_slice(key_cache_layer, head * head_size, (head + 1) * head_size)), 0, timestep), vec_slice(q, head * head_size, (head + 1) * head_size))\n\ndef invariant2(token_position: int, head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int, attention: List[int]) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and attention == matrix_vec_mul(matrix_row_slice(matrix_scalar_div(integer_sqrt(head_size), matrix_col_slice(key_cache_layer, head * head_size, (head + 1) * head_size)), 0, timestep), vec_slice(q, head * head_size, (head + 1) * head_size)) and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), vec_slice(key_cache_layer[timestep], head*head_size, (head + 1)*head_size))) // integer_sqrt(head_size)\n", "\ndef invariant1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, attention: List[int]) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size))\n\ndef invariant2(token_position: int, head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), key_cache_layer[timestep])) // integer_sqrt(head_size)\n", "\ndef invariant1(attention: List[int], head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, token_position: int) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\ndef invariant2(attention: List[int], head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int, token_position: int) -> bool:\n    return i >= 0 and i < head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), vec_slice(key_cache_layer[timestep], head*head_size, (head + 1)*head_size))) // integer_sqrt(head_size) \n", "\ndef invariant1(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, attention: List[int]) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\ndef invariant2(token_position: int, head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, i: int, score: int, attention: List[int]) -> bool:\n    return i >= 0 and i < head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), key_cache_layer[timestep]))//integer_sqrt(head_size) and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n", "\ndef invariant1(attention: List[int], head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, token_position: int) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\ndef invariant2(attention: List[int], head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int, token_position: int) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size), key_cache_layer[timestep])) // integer_sqrt(head_size) and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n", "\ndef invariant1(attention: List[int], head: int, head_size: int, key_cache_layer: List[List[int]], q: List[int], timestep: int, token_position: int) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\ndef invariant2(attention: List[int], head: int, head_size: int, i: int, key_cache_layer: List[List[int]], q: List[int], score: int, timestep: int, token_position: int) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size)[:i], vec_slice(key_cache_layer[timestep], head*head_size, (head + 1)*head_size)[:i])) and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n", "\n# Loop Invariant for the first loop\ndef invariant1(token_position: int, timestep: int, attention: List[int], q: List[int], key_cache_layer: List[List[int]], head: int, head_size: int) -> bool:\n    return timestep >= 0 and timestep <= token_position and attention == matrix_vec_mul( matrix_row_slice( matrix_scalar_div( integer_sqrt(head_size), matrix_col_slice( key_cache_layer, head * head_size, (head + 1) * head_size ) ), 0, timestep ), vec_slice(q, head*head_size, (head + 1)*head_size) )\n\n# Loop Invariant for the second loop\ndef invariant2(token_position: int, timestep: int, i:int, score: int, q: List[int], key_cache_layer: List[List[int]], head: int, head_size: int) -> bool:\n    return i >= 0 and i <= head_size and timestep >= 0 and timestep < token_position and score == reduce_sum(vec_elemwise_mul(vec_slice(q, head*head_size, (head + 1)*head_size)[:i], vec_slice(key_cache_layer[timestep], head*head_size, (head + 1)*head_size)[:i])) // integer_sqrt(head_size)\n"]
