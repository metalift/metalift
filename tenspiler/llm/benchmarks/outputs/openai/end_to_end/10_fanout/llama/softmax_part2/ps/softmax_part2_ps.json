["\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_slice(input, 0, max_pos), lambda x: integer_exp(x - max_val))\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_slice(input, 0, i), lambda x: integer_exp(x - max_val))\n", "\nfrom typing import List\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][start:]\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_elemwise_sub(vec_slice(input, 0, max_pos), [max_val] * max_pos), integer_exp)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_elemwise_sub(vec_slice(input, 0, i), [max_val] * i), integer_exp)\n", "\ndef softmax_part2(input: list[int], max_pos: int, max_val: int) -> list[int]:\n    return vec_elemwise_sub(vec_map(input[:max_pos], integer_exp), [max_val]*max_pos)\n\n\n\ndef invariant(i: int, input: list[int], max_pos: int, max_val: int, output: list[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_elemwise_sub(vec_map(input[:i], integer_exp), [max_val]*i)\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_elemwise_sub(input[:max_pos], [max_val]*max_pos), integer_exp)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_elemwise_sub(input[:i], [max_val]*i), integer_exp)\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_elemwise_sub(vec_slice(input, 0, max_pos), [max_val]*max_pos), integer_exp)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_elemwise_sub(vec_slice(input, 0, i), [max_val]*i), integer_exp)\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_elemwise_sub(input[:max_pos], [max_val]*max_pos), integer_exp)\n\n\n\ndef invariant(cur: int, i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and cur == integer_exp(input[i] - max_val) and output == vec_map(vec_elemwise_sub(input[:i], [max_val]*i), integer_exp)\n", "\nfrom typing import List\n\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_elemwise_sub(vec_slice(input, 0, max_pos), [max_val]*max_pos)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_elemwise_sub(vec_slice(input, 0, i), [max_val]*i)\n", "\ndef softmax_part2_helper(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return (\n        []\n        if max_pos < 1\n        else [integer_exp(input[0] - max_val), *softmax_part2_helper(input[1:], max_pos-1, max_val)]\n    )\n\n\n\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return softmax_part2_helper(input, max_pos, max_val)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == softmax_part2_helper(input[:i], i, max_val)\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_map(vec_elemwise_sub(input[:max_pos], [max_val]*max_pos), integer_exp)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_map(vec_elemwise_sub(input[:i], [max_val]*i), integer_exp)\n", "\ndef softmax_part2(input: List[int], max_pos: int, max_val: int) -> List[int]:\n    return vec_elemwise_sub(vec_slice(input, 0, max_pos), [max_val]*max_pos)\n\n\n\ndef invariant(i: int, input: List[int], max_pos: int, max_val: int, output: List[int]) -> bool:\n    return i >= 0 and i <= max_pos and output == vec_elemwise_sub(vec_slice(input, 0, i), [max_val]*i)\n"]
