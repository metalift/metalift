[{"role": "system", "content": "You are a helpful expert in programming languages."}, {"role": "user", "content": "\n    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function.\n    #Instructions\n    # 1. Do not use for/while loops for rewriting the function.\n    # 2. The rewritten program should just be a single return statement of the form return_var = provided_function(...)\n    # 3. Inline all the expressions. Do not use intermediate variables.\n    ```\n    #defined functions\n    from typing import Callable, List\n\n\ndef matrix_scalar_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_sub(a, matrix_x[0]), *matrix_scalar_sub(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_mul(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_mul(a, matrix_x[0]), *matrix_scalar_mul(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_div(a, matrix_x[0]), *matrix_scalar_div(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]\n    )\n\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][:start]\n\n\ndef matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return matrix[:end][start:]\n\n\ndef matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return (\n        []\n        if len(matrix) < 1\n        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]\n    )\n\n\ndef firsts(matrix: List[List[int]]) -> List[int]:\n    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]\n\n\ndef rests(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))\n\n\ndef matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]\n\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\n\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\n\ndef vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]\n    )\n\n\ndef matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:\n    return (\n        []\n        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)\n        else [\n            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),\n            *matrix_vec_mul(matrix_x[1:], x),\n        ]\n    )\n\n\ndef vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]\n    )\n\n\ndef matrix_elemwise_add(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_add(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_sub(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_sub(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_mul(x: List[int]) -> int:\n    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])\n\n\ndef matrix_elemwise_mul(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_mul(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_div(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_div(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef vec_scalar_add(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a + x[0], *vec_scalar_add(a, x[1:])]\n\n\ndef vec_scalar_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] - a), *vec_scalar_sub(a, x[1:])]\n\n\ndef vec_scalar_mul(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a * x[0], *vec_scalar_mul(a, x[1:])]\n\n\ndef vec_scalar_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] // a), *vec_scalar_div(a, x[1:])]\n\n\ndef scalar_vec_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a - x[0]), *scalar_vec_sub(a, x[1:])]\n\n\ndef scalar_vec_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a // x[0]), *scalar_vec_div(a, x[1:])]\n\n\ndef matrix_scalar_add(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_add(a, matrix_x[0]), *matrix_scalar_add(a, matrix_x[1:])]\n    )\n\n\ndef reduce_sum(x: List[int]) -> int:\n    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])\n\n\ndef integer_sqrt(n: int) -> int:\n    return integer_sqrt_helper((n // 2), n)\n\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    return a if cond else b\n\n\ndef col_vec(matrix: List[List[int]], col_index: int) -> List[int]:\n    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]\n\n    ```\n    ```\n    //test function\n    #include <vector>\nusing namespace std;\n\nvector<int> normal_blend_8(vector<int> base, vector<int> active, int opacity)\n{\n  vector<int> out;\n  for (int i = 0; i < base.size(); ++i)\n    out.push_back(opacity * active[i] + (32 - opacity) * base[i]);\n\n  return out;\n}\n\n    ```\n    "}, {"role": "assistant", "content": "\ndef normal_blend_8(base, active, opacity):\n    return vec_map(active, lambda a: vec_scalar_mul((opacity * a + (32 - opacity) * vec_first(base)) // 32, range(len(base))))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(base, lambda b: vec_scalar_mul(\n        ite(len(active) > 0, opacity, 0),\n        vec_elemwise_mul(active, vec_scalar_div(vec_scalar_add(32, b), opacity))\n    ))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_elemwise_add(\n        vec_scalar_mul(opacity, active),\n        vec_scalar_mul(32 - opacity, base)\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return matrix_elemwise_add(\n        matrix_elemwise_mul(opacity, active),\n        matrix_elemwise_mul(32 - opacity, base)\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return matrix_elemwise_add(\n        matrix_scalar_mul(opacity, active),\n        matrix_scalar_mul((32 - opacity), base)\n    )\n\n\n\n# Rethinking the approach based on given functions and ensuring no loop construct is used.\n\ndef normal_blend_8(base, active, opacity):\n    a, b = vec_first(active), vec_first(base)\n    return [ite(0 <= a and 0 <= b, (opacity * a + (32 - opacity) * b) // 32, max((opacity * a + (32 - opacity) * b), 0))]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(active, lambda a: vec_scalar_div((opacity * a + (32 - opacity) * (vec_first(base))), 32))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(active, lambda active_val: opactiy * active_val + (32 - opacity) * base_val)\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_elemwise_add(\n        vec_elemwise_mul(opacity, active),\n        vec_elemwise_mul((32 - opacity), base)\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [opacity * active_val + (32 - opacity) * base_val for active_val, base_val in zip(active, base)]\n\n\n\nimport itertools\n\ndef normal_blend_8(base, active, opacity):\n    blended = [(opacity * a + (32 - opacity) * b) // 32 for a, b in itertools.zip_longest(base, active, fillvalue=0)]\n    return list(itertools.filterfalse(lambda x: x > 31, blended))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    if not base:\n        return []\n    else:\n        base_val, *rest_base = base\n        active_val, *rest_active = active\n        return [(opacity * active_val + (32 - opacity) * base_val)] + normal_blend_8(rest_base, rest_active, opacity)\n\n\n\ndef lift2(f, lst1, lst2):\n    return [(f(x, y),) for x, y in zip(lst1, lst2)]\n\ndef normal_blend_8(base, active, opacity):\n    return [((opacity * a + (32 - opacity) * b) // 32) for a, b in lift2(lambda a, b: (a, b), active, base)]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(\n        active,\n        lambda active_val: vec_map(\n            base,\n            lambda base_val: (opacity * active_val + (32 - opacity) * base_val) // 32\n        )\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(\n        active,\n        lambda active_val: vec_map(\n            base,\n            lambda base_val: ite(len(base) > 0, (opacity * active_val + (32 - opacity) * base_val) // 32, 0)\n        )\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [\n        ite(0 <= a <= 31 and 0 <= b <= 31, (opacity * a + (32 - opacity) * b) // 32, 31)\n        for a, b in zip(active, base)\n    ]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [[opacity * i + (32 - opacity) * j for i, j in zip(active_row, base_row)] for active_row, base_row in zip(active, base)]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    out = []\n    active\u0a3f\u0a24 = active[0] if len(active) > 0 else 0\n    base \u0412\u0430\u043b = base[0] if len(base) > 0 else 0\n\n    out.append(opacity * active republican + (32 - opacity) * base \u0412\u0430\u043b)\n\n    if len(base) > 1:\n        out.extend(normal_blend_8(base[1:], active[1:], opacity))\n\n    return out\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(\n        vec_elemwise_add(\n            vec_scalar_mul(opacity, active),\n            vec_scalar_mul(32 - opacity, base)\n        ),\n        lambda x: reduce_min(x)\n    )\n\n\n\nimport numpy as np\n\ndef normal_blend_8(base, active, opacity):\n    base = np.array(base)\n    active = np.array(active)\n    opacity = np.array([opacity])\n\n    return (opacity * active + (32 - opacity) * base).tolist()\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return matrix_map(lambda x, y: vec_map(lambda a, b: ite(a <= 31 and b <= 31, (opacity * a + (32 - opacity) * b) // 32, max((opacity * a + (32 - opacity) * b), 0)), x, y), active, base)\n\n\n\ndef matrix_map(f, xs, ys):\n    return [\n        f(x, y)\n        for x, y in zip(xs, ys)\n    ] if len(xs) > 0 else []\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return list(map(lambda a, b: (opacity * a + (32 - opacity) * b) // 32, active, base))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    blended = vec_map(active, lambda a: vec_scalar_mul(\n        opacity,\n        a\n    )) + vec_map(base, lambda b: vec_scalar_mul(\n        32 - opacity,\n        b\n    ))\n    return vec_map(blended, lambda x: reduce_sum(x) // 32)\n\n\n\ndef normal_blend_8(base, active, opacity):\n    blended = [(opacity * a + (32 - opacity) * b) for a, b in zip(active, base)]\n    return blended if len(blended) > 0 else []\n\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [(opacity * ac + (32 - opacity) * base) for base, ac in zip(base, active)]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [(opacity * a + (32 - opacity) * b) for a, b in zip(active, base)]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(\n        active,\n        lambda a: vec_scalar_mul(\n            (opacity * a + (32 - opacity) * vec_first(base)) // 32,\n            range(len(base))\n        )\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    if not base:\n        return []\n\n    opacity, accounted_opacity = opacity, 0\n\n    def blend(val_base, val_active):\n        return (\n            (integer_exp(2 * opacity) * val_base\n            + (integer_exp(32) - integer_exp(2 *.opacity) + accounted_opacity * integer_sqrt(integer_exp(4)))) // integer_exp(34)\n        )\n\n    blended, *rest_base, *rest_active = zip(*map(blend, base, active))\n    accounted_opacity += opacity\n\n    return list(blended) + normal_blend_8(rest_base, rest_active, accounted_opacity)\n\n\n\n!pip install numpy\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return matrix_elemwise_add(\n        matrix_scalar_mul(opacity, active),\n        matrix_scalar_mul(32 - opacity, base)\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [(opacity * a + (32 - opacity) * b) // 32 for a, b in zip(active, base)] if base else []\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [\n        opacity * a + (32 - opacity) * b\n        for a, b in zip(active, base)\n    ]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(active, lambda ac: vec_map(base, lambda b: ite(0 <= ac <= 31 and 0 <= b <= 31, (opacity * ac + (32 - opacity) * b) // 32, 31)))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [\n        ite(len(base) == 0, 0,\n            opacity * active[0] + (32 - opacity) * base[0])\n        if len(base) > 0 else []\n    ] + normal_blend_8(base[1:], active[1:], opacity)\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [((opacity * a) + ((32 - opacity) * b)) // 32 for a, b in zip(active, base) if a <= 31 and b <= 31]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [] if not base else [\n        (opacity * active_pop + (32 - opacity) * base_pop) // 32\n        for active_pop, base_pop in zip(active, base)\n    ] + normal_blend_8(base[1:], active[1:] if active else [], opacity)\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [] if len(base) == 0 else [\n        opacity * active[0] + (32 - opacity) * base[0],\n        *normal_blend_8(base[1:], active[1:], opacity)\n    ]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return matrix_elemwise_mul(\n        matrix_elemwise_add(\n            matrix_scalar_mul(opacity, active),\n            matrix_scalar_mul(32 - opacity, base)\n        ),\n        [32] * len(base)\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    opacity_matrix = [[opacity]] * len(base)\n    return (\n        matrix_elemwise_add(\n            matrix_elemwise_mul(opacity_matrix, active),\n            matrix_elemwise_mul((32 - opacity_matrix), base)\n        )\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    def blendirical(a, b):\n        return (opacity * a + (32 - opacity) * b) // 32\n\n    return vec_map(active, lambda ac: vec_map(base, lambda ba: blendirical(ac, ba)))\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [\n        (opacity * a + (32 - opacity) * b) // 32\n        if 0 <= a <= 31 and 0 <= b <= 31\n        else max((opacity * a + (32 - opacity) * b), 0)\n        for a, b in zip(active, base)\n    ]\n\n\n\ndef normal_blend_8(base, active, opacity):\n    if not base:\n        return []\n\n    base_val, *rest_base = base\n    active_val, *rest_active = active\n\n    return [(opacity * active_val + (32 - opacity) * base_val)] + normal_blend_8(rest_base, rest_active, opacity)\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return vec_map(\n        active,\n        lambda a: vec_map(\n            base,\n            lambda b: (opacity * a + (32 - opacity) * b + 0.5) // 1\n        )\n    )\n\n\n\ndef normal_blend_8(base, active, opacity):\n    if not base:\n        return []\n    else:\n        base_val, *rest_base = base\n        active_val, *rest_active = active\n        return [(opacity * active_val + (32 - opacity) * base_val) // 32] + normal_blend_8(rest_base, rest_active, opacity)\n\n\n\ndef normal_blend_8(base, active, opacity):\n    return [\n        ((opacity * ac + (32 - opacity) * b) // 32)\n        if 0 <= ac <= 31 and 0 <= b <= 31\n        else max((opacity * ac + (32 - opacity) * b), 0)\n        for ac, b in zip(active, base)\n    ]\n"}, {"role": "user", "content": "These generated programs are incorrect. Do not generate the same. Please generate another program."}]
