[{"role": "system", "content": "You are a helpful expert in programming languages."}, {"role": "user", "content": "\n    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function.\n    #Instructions\n    # 1. Do not use for/while loops for rewriting the function.\n    # 2. The rewritten program should just be a single return statement of the form return_var = provided_function(...)\n    # 3. Inline all the expressions. Do not use intermediate variables.\n    ```\n    #defined functions\n    from typing import Callable, List\n\n\ndef matrix_scalar_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_sub(a, matrix_x[0]), *matrix_scalar_sub(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_mul(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_mul(a, matrix_x[0]), *matrix_scalar_mul(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_div(a, matrix_x[0]), *matrix_scalar_div(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]\n    )\n\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][:start]\n\n\ndef matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return matrix[:end][start:]\n\n\ndef matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return (\n        []\n        if len(matrix) < 1\n        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]\n    )\n\n\ndef firsts(matrix: List[List[int]]) -> List[int]:\n    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]\n\n\ndef rests(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))\n\n\ndef matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]\n\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\n\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\n\ndef vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]\n    )\n\n\ndef matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:\n    return (\n        []\n        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)\n        else [\n            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),\n            *matrix_vec_mul(matrix_x[1:], x),\n        ]\n    )\n\n\ndef vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]\n    )\n\n\ndef matrix_elemwise_add(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_add(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_sub(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_sub(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_mul(x: List[int]) -> int:\n    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])\n\n\ndef matrix_elemwise_mul(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_mul(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_div(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_div(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef vec_scalar_add(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a + x[0], *vec_scalar_add(a, x[1:])]\n\n\ndef vec_scalar_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] - a), *vec_scalar_sub(a, x[1:])]\n\n\ndef vec_scalar_mul(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a * x[0], *vec_scalar_mul(a, x[1:])]\n\n\ndef vec_scalar_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] // a), *vec_scalar_div(a, x[1:])]\n\n\ndef scalar_vec_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a - x[0]), *scalar_vec_sub(a, x[1:])]\n\n\ndef scalar_vec_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a // x[0]), *scalar_vec_div(a, x[1:])]\n\n\ndef matrix_scalar_add(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_add(a, matrix_x[0]), *matrix_scalar_add(a, matrix_x[1:])]\n    )\n\n\ndef reduce_sum(x: List[int]) -> int:\n    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])\n\n\ndef integer_sqrt(n: int) -> int:\n    return integer_sqrt_helper((n // 2), n)\n\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    return a if cond else b\n\n\ndef col_vec(matrix: List[List[int]], col_index: int) -> List[int]:\n    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]\n\n    ```\n    ```\n    //test function\n    #include <vector>\nusing namespace std;\n\nvector<vector<int>> screen_blend_8(vector<vector<int>> base, vector<vector<int>> active)\n{\n    vector<vector<int>> out;\n    int m = base.size();\n    int n = base[0].size();\n\tfor (int row = 0; row < m; row++) {\n        vector<int> row_vec;\n\t\tfor (int col = 0; col < n; col++) {\n\t\t\tint pixel = base[row][col] + active[row][col] - (base[row][col] * active[row][col]) / 32;\n\t\t\trow_vec.push_back(pixel);\n\t\t}\n\t\tout.push_back(row_vec);\n\t}\n\treturn out;\n}\n\n    ```\n    "}, {"role": "assistant", "content": "\ndef screen_blend_8(base, active):\n    return [[b + a - (b * a // 32) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    return [\n        [\n            max(0, min(255, b + a - ((b * a) // 32)))\n            for b, a in zip(base_row, active_row)\n        ]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: reduce_mul(256, ite((b + a - b * a // 32) < 0, 0, ((b + a - b * a // 32) % 256))),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    blend_pixels = lambda b, a: min(255, max(0, b + a - (b * a // 32)))\n    return [[blend_pixels(b, a) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\nfrom functools import reduce\nfrom operator import add\n\ndef screen_blend_8(base, active):\n    return [\n        [\n            reduce(\n                add,\n                (b + a - (b * a // 32)) if 0 <= (b + a - (b * a // 32)) <= 255 else 0\n                for b, a in zip(row_base, row_active)\n            )\n            for row_base, row_active in zip(base, active)\n        ]\n    ]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite((b + a - b * a // 32) < 0, 0, min(255, b + a - b * a // 32)),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return [[min(255, max(0, b + a - (b * a // 32))) for b, a in row] for row in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    if not base:\n        return []\n    row_base, *rest_base = base\n    row_active, *rest_active = active\n    blended_row = [max(0, min(255, b + a - (b * a // 32))) for b, a in zip(row_base, row_active)]\n    return [blended_row] + screen_blend_8(rest_base, rest_active)\n\n\n\ndef screen_blend_8(base, active):\n    a, b = matrix_elemwise_sub(active, matrix_scalar_mul(256, matrix_scalar_div(matrix_elemwise_mul(base, active), 32)))\n    return matrixMap(addInt, base, a) + matrixMap(addInt, b)\n\n\n\ndef screen_blend_8(base, active):\n    n = len(base[0])\n    blended_cols = [matrixSlice(\n        vector_where(col_base, col_active, lambda b, a: max(0, min(255, b + a - (b * a // 32)))),\n        0, n\n    ) for col_base, col_active in zip(base, active)]\n    return matrixTranspose(blended_cols)\n\n\n\ndef screen_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda b, a: max(0, min(255, b + a - (b * a // 32))),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return [[max(0, min(255, b + a - (b * a // 32))) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    if not base or not active:\n        return []\n    return [\n        [(b + a - (b * a // 32)) if 0 <= (b + a - (b * a // 32)) <= 255 else 0\n         for b, a in zip(base[0], active[0])]\n        + screen_blend_8(base[1:], active[1:])[0]\n        if base and active\n        else []\n    ]\n\n\n\ndef screen_blend_8(base, active):\n    blended = [[(b + a - (b * a // 32)) for b, a in zip(base_row, active_row)] for base_row, active_row in zip(base, active)]\n    return blended\n\n\n\ndef screen_blend_8(base, active):\n    return [\n        [max(0, min(255, b + a - ((b * a) >> 5))) for b, a in zip(base_row, active_row)]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(b + a - b * a // 32 < 0, 0, min(255, b + a - b * a // 32)),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    m, n = len(base), len(base[0])\n    blended = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            blended[i][j] = max(0, min(255, base[i][j] + active[i][j] - (base[i][j] * active[i][j]) // 32))\n    return blended\n\n\n\ndef screen_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    base_flattened = [item for sublist in base for item in sublist]\n    active_flattened = [item for sublist in active for item in sublist]\n    blended_flattened = [(a + b - (a * b // 32)) for a, b in zip(base_flattened, active_flattened)]\n    m, n = len(base), len(base[0])\n    return [blended_flattened[i:i + n] for i in range(0, len(blended_flattened), n)]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(lambda b, a: reduce_mul(256, ite((b + a - b * a // 32) < 0, 0, (b + a - b * a // 32) % 256)), base, active)\n\n\n\ndef screen_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(\n        matrix_elemwise_add(base, active),\n        matrix_scalar_mul(2, matrix_elemwise_div(matrix_elemwise_mul(base, active), 32)),\n        lambda a, b: a + b - (a * b // 32),\n    )\n\n\n\ndef screen_blend_8(base, active):\n    blended = (base + active - (base * active.bitwise_right_shift(5))).clip(min=0, max=255)\n    return blended.tolist()\n\n\n\ndef screen_blend_8(base, active):\n    return [\n        [\n            ite(\n                (b + a - b*a // 32) < 0,\n                0,\n                min(255, max(0, b + a - b*a // 32))\n            )\n            for b, a in zip(base_row, active_row)\n        ]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef screen_blend_8(base, active, i=0, j=0, blended=None):\n    if blended is None:\n        blended = []\n    if i == len(base):\n        return blended\n    elif j == len(base[0]):\n        return screen_blend_8(base, active, i + 1, 0, blended)\n    else:\n        b, *rest_b = base[i]\n        a, *rest_a = active[i]\n        blended_pixel = max(0, min(255, b + a - (b * a // 32)))\n        return screen_blend_8(base, active, i, j + 1, blended + [blended_pixel])\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            (b + a - (b * a >> 5)) < 0, 0,\n            ite((b + a - (b * a >> 5)) > 255, 255, (b + a - (b * a >> 5)))\n        ),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return [[max(0, min(255, b + a - (b * a // 32))) for b, a in zip(base_row, active_row)] for base_row, active_row in zip(base, active)]\n\n\n\ndef blend_pixel(b, a):\n    return max(0, min(255, b + a - (b * a // 32)))\n\ndef screen_blend_8(base, active):\n    return [[blend_pixel(b, a) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(b + a - b * a // 32 < 0, 0, ite(b + a - b * a // 32 > 255, 255, b + a - b * a // 32)),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: vector_where(\n            [a, b, a, (b * a) // 32],\n            reduce_add\n        ),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    def blend_rows(i, j, m, n):\n        if i == m:\n            return []\n        else:\n            b, *rest_b = base[i]\n            a, *rest_a = active[i]\n            return [[max(0, min(255, (b + a) - ((b << 5) & a >> 5)))] + blend_rows(i + 1, j + 1, m, n)[0]]\n\n    return blend_rows(0, 0, len(base), len(base[0]))\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: reduce_mul(\n            256,\n            ite(\n                (b + a - (b * a // 32)) < 0,\n                0,\n                (b + a - (b * a // 32)) % 256\n            )\n        ),\n        base,\n        active\n    )\n\n\n\ndef blend_pixel(b, a):\n    return max(0, min(255, b + a - (b * a // 32)))\n\ndef screen_blend_8(base, active):\n    return [[blend_pixel(b, a) for b, a in zip(base_row, active_row)] for base_row, active_row in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    lambda_func = lambda b, a: max(0, min(255, b + a - (b * a // 32)))\n    return matrix_map(lambda_func, base, active)\n\n\n\ndef screen_blend_8(base, active):\n    def blend_row(base_row, active_row):\n        if not base_row:\n            return []\n        else:\n            b, *rest_b = base_row\n            a, *rest_a = active_row\n            return [b + a - (b * a // 32)] + blend_row(rest_b, rest_a)\n\n    if not base:\n        return []\n    else:\n        base_row, *rest_base = base\n        active_row, *rest_active = active\n        return [blend_row(base_row, active_row)] + screen_blend_8(rest_base, rest_active)\n\n\n\ndef screen_blend_8(base, active):\n    blended = [[max(0, min(255, b + a - (b * a // 32))) for b, a in zip(base_row, active_row)] for base_row, active_row in zip(base, active)]\n    return blended\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            (b + a - (b * a // 32)) < 0, 0,\n            min(255, (b + a - (b * a // 32)))\n        ),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            (b + a - (b * a // 32)) < 0, 0,\n            ite((b + a - (b * a // 32)) > 255, 255, (b + a - (b * a // 32)))\n        ),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    if len(base) != len(active) or len(base[0]) != len(active[0]):\n        raise ValueError(\"Input matrices must have the same dimensions\")\n    return [[max(0, min(255, b + a - (b * a // 32))) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: reduce_mul(\n            256,\n            ite(\n                (b + a - b * a // 32) < 0,\n                0,\n                (b + a - b * a // 32) % 256\n            )\n        ),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: min(255, max(0, b + a - ((b * a) >> 5))),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            (b + a) - (b * a // 32) < 0,\n            0,\n            ite(\n                (b + a) - (b * a // 32) > 255,\n                255,\n                (b + a) - (b * a // 32)\n            )\n        ),\n        base,\n        active\n    )\n\n\n\ndef screen_blend_8(base, active, i=0, j=0, blended=None):\n    if blended is None:\n        blended = []\n\n    if i == len(base):\n        return blended\n\n    row_base, *rest_base = base\n    row_active, *rest_active = active\n\n    if j == len(row_base):\n        return screen_blend_8(rest_base, rest_active, i, 0, blended)\n\n    b, *rest_b = row_base\n    a, *rest_a = row_active\n\n    blended_pixel = max(0, min(255, b + a - (b * a // 32)))\n    result = screen_blend_8(rest_base, rest_active, i, j + 1, blended + [blended_pixel])\n\n    return result\n\n\n\nfrom typing import List\n\ndef blend_screens(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_row(base_row: List[int], active_row: List[int]) -> List[int]:\n        blended_row = []\n        for b, a in zip(base_row, active_row):\n            blended_pixel = b + a - (b * a // 32)\n            blended_row.append(max(0, min(255, blended_pixel)))\n        return blended_row\n\n    return [[*blend_row(base_row, active_row)] for base_row, active_row in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            (b + a - (b * a // 32)) < 0, 0, min(255, (b + a - (b * a // 32)))\n        ),\n        base,\n        active\n    )\n\n\n\nimport operator\n\ndef screen_blend_8(base, active):\n    op_add = operator.add\n    op_sub = operator.sub\n    op_lshift = operator.lshift\n    op_rshift = operator.rshift\n\n    return [\n        [max(0, min(255, op_add(b, a) - (op_rshift(op_lshift(b, 5), 5) * a))) for b, a in zip(base_row, active_row)]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef screen_blend_8(base, active):\n    blended = vec_map(lambda b, a: ite(b + a - b * a // 32 < 0, 0, min(255, b + a - b * a // 32)), vec_zip(base, active))\n    return matrix_row_slice(matrix_col_slice(matrix_transpose(blended), 0, len(base)), 0, len(base[0]))\n\n\n\ndef screen_blend_8(base, active):\n    return [\n        [max(0, min(255, b + a - (b * a >> 5))) for b, a in zip(base_row, active_row)]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef screen_blend_8(base, active):\n    return [[min(255, max(0, b + a - (b * a // 32))) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef screen_blend_8(base, active):\n    return matrix_map(\n        lambda row_base, row_active: vec_map(\n            lambda b, a: blend(b, a),\n            vec_zip(row_base, row_active)\n        ),\n        base,\n        active\n    )\n\ndef blend(b, a):\n    blended_pixel = b + a - (b * a // 32)\n    return min(255, max(0, blended_pixel))\n"}, {"role": "user", "content": "These generated programs are incorrect. Do not generate the same. Please generate another program."}]
