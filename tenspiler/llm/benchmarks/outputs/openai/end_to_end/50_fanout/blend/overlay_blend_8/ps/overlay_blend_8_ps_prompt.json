[{"role": "system", "content": "You are a helpful expert in programming languages."}, {"role": "user", "content": "\n    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function.\n    #Instructions\n    # 1. Do not use for/while loops for rewriting the function.\n    # 2. The rewritten program should just be a single return statement of the form return_var = provided_function(...)\n    # 3. Inline all the expressions. Do not use intermediate variables.\n    ```\n    #defined functions\n    from typing import Callable, List\n\n\ndef matrix_scalar_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_sub(a, matrix_x[0]), *matrix_scalar_sub(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_mul(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_mul(a, matrix_x[0]), *matrix_scalar_mul(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_div(a, matrix_x[0]), *matrix_scalar_div(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]\n    )\n\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][:start]\n\n\ndef matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return matrix[:end][start:]\n\n\ndef matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return (\n        []\n        if len(matrix) < 1\n        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]\n    )\n\n\ndef firsts(matrix: List[List[int]]) -> List[int]:\n    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]\n\n\ndef rests(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))\n\n\ndef matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]\n\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\n\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\n\ndef vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]\n    )\n\n\ndef matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:\n    return (\n        []\n        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)\n        else [\n            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),\n            *matrix_vec_mul(matrix_x[1:], x),\n        ]\n    )\n\n\ndef vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]\n    )\n\n\ndef matrix_elemwise_add(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_add(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_sub(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_sub(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_mul(x: List[int]) -> int:\n    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])\n\n\ndef matrix_elemwise_mul(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_mul(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_div(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_div(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef vec_scalar_add(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a + x[0], *vec_scalar_add(a, x[1:])]\n\n\ndef vec_scalar_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] - a), *vec_scalar_sub(a, x[1:])]\n\n\ndef vec_scalar_mul(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a * x[0], *vec_scalar_mul(a, x[1:])]\n\n\ndef vec_scalar_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] // a), *vec_scalar_div(a, x[1:])]\n\n\ndef scalar_vec_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a - x[0]), *scalar_vec_sub(a, x[1:])]\n\n\ndef scalar_vec_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a // x[0]), *scalar_vec_div(a, x[1:])]\n\n\ndef matrix_scalar_add(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_add(a, matrix_x[0]), *matrix_scalar_add(a, matrix_x[1:])]\n    )\n\n\ndef reduce_sum(x: List[int]) -> int:\n    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])\n\n\ndef integer_sqrt(n: int) -> int:\n    return integer_sqrt_helper((n // 2), n)\n\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    return a if cond else b\n\n\ndef col_vec(matrix: List[List[int]], col_index: int) -> List[int]:\n    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]\n\n    ```\n    ```\n    //test function\n    #include <vector>\nusing namespace std;\n\nvector<vector<int>> overlay_blend_8(vector<vector<int>> base, vector<vector<int>> active)\n{\n    vector<vector<int>> out;\n    int m = base.size();\n    int n = base[0].size();\n\tfor (int row = 0; row < m; row++) {\n        vector<int> row_vec;\n\t\tfor (int col = 0; col < n; col++) {\n\t\t\tint pixel;\n\t\t\tif (base[row][col] >= 16)\n                pixel = 2 * base[row][col] + base[row][col] - 2 * base[row][col] * base[row][col] / 32 - 32;\n\t\t\telse\n                pixel = 2 * base[row][col] * base[row][col] / 32;\n\t\t\trow_vec.push_back(pixel);\n\t\t}\n\t\tout.push_back(row_vec);\n\t}\n\treturn out;\n}\n\n    ```\n    "}, {"role": "assistant", "content": "\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        if pixel >= 16:\n            return 2 * (pixel - (pixel // 32 + 1)) - 32\n        else:\n            return pixel * pixel // 16\n\n    return [[blend_pixel(pixel) for pixel in row] for row in base]\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        \"\"\"Blend a single pixel, applying the overlay blend 8 algorithm.\"\"\"\n        if pixel >= 16:\n            return 2 * pixel - (2 * (pixel // 32)) - 32\n        else:\n            return pixel * pixel // 16\n\n    def blend_row(row: List[int]) -> List[int]:\n        \"\"\"Blend a single row of pixels, applying the 'blend_pixel' function to each pixel.\"\"\"\n        return [blend_pixel(pixel) for pixel in row]\n\n    def blend_matrix(matrix: List[List[int]]) -> List[List[int]]:\n        \"\"\"Blend a matrix of pixels, applying the 'blend_row' function to each row.\"\"\"\n        if not matrix:\n            return []\n        else:\n            return [blend_row(matrix[0])] + blend_matrix(matrix[1:])\n\n    return blend_matrix(base)\n\n\n\nfrom typing import List\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    # Create a matrix of the same size filled with 16\n    mask = [[16] * len(base[0]) for _ in range(len(base))]\n\n    # Blend operation using matrix multiplication and scalar addition\n    blended = matrix_elemwise_mul(base, reduce_vec(2)) + matrix_elemwise_div(mask, matrix_elemwise_mul(reduce_vec(32), reduce_vec(2)))\n\n    # Apply the overlay blend 8 formula only for pixels >= 16\n    blended = matrix_where(blended, blended, lambda x, y: ite(x >= 16, y, x))\n\n    # Apply the final overlay blend 8 formula\n    blended = matrix_map(lambda x: ite(x >= 16, 2 * x + x - 2 * (x // 32) - 32, 2 * x * x // 16), blended)\n\n    return blended\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(base: int) -> int:\n        if base < 16: return base * (base // 16)\n        return 2 * base * (base // 32) - 32\n\n    return [[blend_pixel(base[row][col]) for col in range(len(base[0]))] for row in range(len(base))]\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    if not base: return []\n    blended_row = (blend_pixel(base[0][col]) for col in range(len(base[0])))\n    return [blended_row] + overlay_blend_8(base[1:], active[1:])\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            2 * base[r][c] * (2 * base[r][c] // 32 + 1 - base[r][c] // 16) - 32,\n            2 * base[r][c] * (base[r][c] // 16)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            vec_scalar_mul(2, vector_scalar_add(base[r][c], base[r][c])) - vec_scalar_mul(2, integer_sqrt(base[r][c])) - 32,\n            vec_scalar_mul(2, integer_sqrt(base[r][c]))\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            2 * base[r][c] * (2 * base[r][c] // 32 + 1) - 32,\n            2 * base[r][c] * (base[r][c] // 16)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        if pixel < 16:\n            return 2 * pixel * (pixel // 16)\n        else:\n            return 2 * pixel - (2 * (pixel // 32)) - 32\n\n    return [[blend_pixel(p) for p in row] for row in base]\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [[2 * v * (1 - v // 16) - 32 if v >= 16 else v * v // 16 for v in row] for row in base]\n\n\n\ndef overlay_blend_8(base, active):\n    def blend_pixel(base):\n        return 2 * base * (1 - base // 16) - 32 if base >= 16 else base * base // 32\n\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base, active):\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            (2 * base[r][c]) * (base[r][c] // 16) - 32,\n            (2 * base[r][c]) * (base[r][c] // 16)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda r, c: (2 * base[r][c]) * (1 - base[r][c] // 16) - 32 if base[r][c] >= 16 else (2 * base[r][c]) * (base[r][c] // 32), base)\n\n\n\ndef overlay_blend_8(base, active):\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32),\n            2 * base[r][c] * (base[r][c] // 32)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda r, c: ite(\n        base[r][c] >= 16,\n        2 * base[r][c] - (2 * (base[r][c] // 32) + 1) - 32,\n        (2 * base[r][c]) * (base[r][c] // 16)\n    ), base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        if pixel >= 16:\n            return 2 * (pixel - (pixel // 32 + 1)) - 32\n        else:\n            return pixel * pixel // 16\n\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    if not base:\n        return []\n\n    blend_func = lambda x: 2 * x * (1 - x // 16) - 32 if x >= 16 else x * x // 16\n    return [[blend_func(base[row][col]) for col in range(len(base[0]))] for row in range(len(base))] + overlay_blend_8(base[1:], active[1:])\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        if pixel >= 16:\n            return 2 * pixel + pixel - 2 * (pixel // 32 + 1) - 32\n        else:\n            return 2 * pixel * (pixel // 16)\n\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: miners_silicon_map(base[r][c], 16),\n        base,\n        [None for _ in range(len(base[0]))]\n    )\n\ndef miners_silicon_map(base: int, limit: int) -> int:\n    return 2 * base * (1 - (base // (limit if base >= limit else 16))) - 32 if base >= limit else base * base // 32\n\n\n\ndef overlay_blend_8(base: List[List[int]], _: List[List[int]]) -> List[List[int]]:\n    return [[ite(base[row][col] >= 16, 2 * base[row][col] + base[row][col] - 2 * (base[row][col] // 32) - 32, 2 * base[row][col] * (base[row][col] // 16)) for col in range(len(base[0]))] for row in range(len(base))]\n\n\n\ndef overlay_blend_8(base, active):\n    return [[max(0, (2 * v) * (v // 16) - 32) if v >= 16 else v * (v // 16) for v in row] for row in base]\n\n\n\nfrom typing import List\n\n# Given functions\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    ...\n\ndef matrix_map(map_int_to_int: Callable[[int], int], matrix_x: List[List[int]]) -> List[List[int]]:\n    ...\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    ...\n\n# Helper functions\ndef blend_pixel(pixel: int) -> int:\n    if pixel < 16:\n        return pixel * pixel // 16\n    else:\n        return 2 * pixel + pixel * (2 * pixel // 32) - 32\n\n# Main function\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    m, n = len(base), len(base[0])\n    blended = [[0 for _ in range(n)] for _ in range(m)]\n\n    for row in range(m):\n        for col in range(n):\n            blended[row][col] = max(2 * base[row][col] * (base[row][col] ** 0.5) // 32 - 32, 0)\n\n    return blended\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    m, n = len(base), len(base[0])\n    return matrix_map(lambda row: vec_map(lambda col: ite(\n        16 <= base[row][col],\n        2 * base[row][col] + base[row][col] * (1 - 2 * base[row][col] // 32) - 32,\n        2 * base[row][col] * base[row][col] // 32\n    ), range(n)), range(m))\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: (2 * base[r][c]) * (1 - min(1, base[r][c] // 16)) - 32 if base[r][c] >= 16 else (base[r][c]) * (base[r][c] // 16),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32 + 1) - 32,\n            reduce_mul([base[r][c], base[r][c]] // 16)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            2 * base[r][c] * (base[r][c] // 32 - 1) - 32,\n            base[r][c] * (base[r][c] // 8)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        if pixel >= 16:\n            return 2 * pixel + pixel - 2 * (pixel // 32 + 1) - 32\n        else:\n            return pixel * pixel // 16\n\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r: vec_map(\n            lambda c: ite(\n                base[r][c] >= 16,\n                2 * base[r][c] + base[r][c] - 2 * base[r][c] // 32 - 32,\n                2 * base[r][c] * base[r][c] // 32\n            ),\n            range(len(base[0]))\n        ),\n        range(len(base))\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [[\n        2 * (v if v < 16 else v * (v // 32)) - 32 if v >= 16 else v * (v // 16)\n        for v in row\n    ] for row in base]\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda r, c: (base[r][c] / 12.92) if base[r][c] <= 0.04045 else ((base[r][c] + 0.055) / 1.055) ** 2.4 - 0.00031308, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            (2 * base[r][c]) + base[r][c] - (2 * (base[r][c] // 16)) - 32,\n            (2 * base[r][c]) * (base[r][c] // 16)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda r, c: (2 * base[r][c] * (1 - base[r][c] // 16) - 32) if base[r][c] >= 16 else (2 * base[r][c] * base[r][c] // 32), range(len(base)), range(len(base[0])))\n\n\n\nfrom functools import reduce\nfrom typing import List\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [\n            reduce(\n                lambda p, n: 2 * p * (1 - n // 16) - 32 if p >= 16 else p * p // 32,\n                col,\n                base[row][col]\n            )\n            for col in range(len(base[0]))\n        ]\n        for row in range(len(base))\n    ]\n\n\n\ndef overlay_blend_8(base, active):\n    return matrix_map(\n        lambda r, c: (2 * base[r][c] * (base[r][c] // 16)) - 32 if base[r][c] >= 16 else (2 * base[r][c] * base[r][c] // 32),\n        base\n    )\n\n\n\ndef blend_pixel(base: int) -> int:\n    if base >= 16:\n        return 2 * (base - (base // 32 + 1)) - 32\n    else:\n        return base * base // 16\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(base: int) -> int:\n        return 2 * (base - (base >> 2) - 32) if base >= 16 else (base * base) >> 8\n\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base, active):\n    return [[(2 * (v if v < 16 else v * (v // 32))) - 32 if v >= 16 else v * (v // 16) for v in row] for row in map(list, zip(*base))]\n\n\n\noverlay_blend_8 = lambda b, a: matrix_map(lambda r, c: int((2 * (c + c - (c // 16 if c >= 16 else 0) - 32) if c >= 16 else (c * c) // 16), base=b, active=a)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda r, c: (2 * base[r][c] * (1 - min(1, base[r][c] // 16))) - 32 if base[r][c] >= 16 else (base[r][c] * base[r][c]) // 32, base)\n\n\nI understand, I will generate a different version of the program.\n\n\n{\n  \"code\": \"def overlay_blend_8(base, active):\\n    return [[2 * (v if v < 16 else v * (v // 32)) - 32 if v >= 16 else v * (v // 16) for v in row] for row in base]\\n\"\n}\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_pixel(pixel: int) -> int:\n        if pixel < 16:\n            return (pixel * pixel) // 16\n        else:\n            return 2 * pixel * (pixel // 32) - 32\n\n    return matrix_map(blend_pixel, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: (2 * base[r][c] * (base[r][c] // 16)) - 32 if base[r][c] >= 16 else (2 * base[r][c] * base[r][c] // 32),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        vec_map(lambda col: 2 * base[row][col] *\n                (1 - (base[row][col] // 16 if base[row][col] >= 16 else 0)) - 32 if base[row][col] >= 16 else base[row][col] * base[row][col] // 32, range(len(base[0])))\n        for row in range(len(base))\n    ]\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r, c: ite(\n            base[r][c] >= 16,\n            2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32) - 32,\n            (2 * base[r][c]) * (base[r][c] // 16)\n        ),\n        base\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda r: vec_map(\n            lambda c: ite(\n                base[r][c] >= 16,\n                2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32 + 1),\n                2 * base[r][c] * (base[r][c] // 16)\n            ),\n            range(len(base[0]))\n        ),\n        range(len(base))\n    )\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def blend_func(x: int) -> int:\n        if x >= 16:\n            return 2 * (x - 2 * (x // 32)) - 32\n        else:\n            return x * (x // 16)\n    return matrix_map(blend_func, base)\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [\n            2 * (v - (v // 32 if v >= 16 else 0)) - 32 if v >= 16\n            else v * (v // 16)\n            for v in row\n        ]\n        for row in base\n    ]\n\n\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [\n            2 * (base[row][col] - base[row][col] // 16) - 32 if base[row][col] >= 16 else base[row][col] * base[row][col] // 32\n            for col in range(len(base[0]))\n        ]\n        for row in range(len(base))\n    ]\n"}, {"role": "user", "content": "These generated programs are incorrect. Do not generate the same. Please generate another program."}]
