[{"role": "system", "content": "You are a helpful expert in programming languages."}, {"role": "user", "content": "\n    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function.\n    #Instructions\n    # 1. Do not use for/while loops for rewriting the function.\n    # 2. The rewritten program should just be a single return statement of the form return_var = provided_function(...)\n    # 3. Inline all the expressions. Do not use intermediate variables.\n    ```\n    #defined functions\n    from typing import Callable, List\n\n\ndef matrix_scalar_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_sub(a, matrix_x[0]), *matrix_scalar_sub(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_mul(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_mul(a, matrix_x[0]), *matrix_scalar_mul(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_div(a, matrix_x[0]), *matrix_scalar_div(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]\n    )\n\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][:start]\n\n\ndef matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return matrix[:end][start:]\n\n\ndef matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return (\n        []\n        if len(matrix) < 1\n        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]\n    )\n\n\ndef firsts(matrix: List[List[int]]) -> List[int]:\n    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]\n\n\ndef rests(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))\n\n\ndef matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]\n\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\n\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\n\ndef vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]\n    )\n\n\ndef matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:\n    return (\n        []\n        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)\n        else [\n            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),\n            *matrix_vec_mul(matrix_x[1:], x),\n        ]\n    )\n\n\ndef vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]\n    )\n\n\ndef matrix_elemwise_add(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_add(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_sub(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_sub(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_mul(x: List[int]) -> int:\n    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])\n\n\ndef matrix_elemwise_mul(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_mul(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_div(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_div(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef vec_scalar_add(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a + x[0], *vec_scalar_add(a, x[1:])]\n\n\ndef vec_scalar_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] - a), *vec_scalar_sub(a, x[1:])]\n\n\ndef vec_scalar_mul(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a * x[0], *vec_scalar_mul(a, x[1:])]\n\n\ndef vec_scalar_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] // a), *vec_scalar_div(a, x[1:])]\n\n\ndef scalar_vec_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a - x[0]), *scalar_vec_sub(a, x[1:])]\n\n\ndef scalar_vec_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a // x[0]), *scalar_vec_div(a, x[1:])]\n\n\ndef matrix_scalar_add(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_add(a, matrix_x[0]), *matrix_scalar_add(a, matrix_x[1:])]\n    )\n\n\ndef reduce_sum(x: List[int]) -> int:\n    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])\n\n\ndef integer_sqrt(n: int) -> int:\n    return integer_sqrt_helper((n // 2), n)\n\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    return a if cond else b\n\n\ndef col_vec(matrix: List[List[int]], col_index: int) -> List[int]:\n    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]\n\n    ```\n    ```\n    //test function\n    #include <vector>\n#include <cstdint>\nusing namespace std;\n\nvector<vector<uint8_t>> multiply_blend_8(vector<vector<uint8_t>> base, vector<vector<uint8_t>> active)\n{\n    vector<vector<uint8_t>> out;\n    uint8_t m = base.size();\n    uint8_t n = base[0].size();\n\tfor (uint8_t row = 0; row < m; row++) {\n        vector<uint8_t> row_vec;\n\t\tfor (uint8_t col = 0; col < n; col++) {\n            uint8_t pixel = (base[row][col] * active[row][col]) / 32;\n\t\t\trow_vec.push_back(pixel);\n\t\t}\n\t\tout.push_back(row_vec);\n\t}\n\treturn out;\n}\n\n    ```\n    "}, {"role": "assistant", "content": "\ndef multiply_blend_8(base, active):\n    return matrix_map(lambda row, a_row: vec_map(lambda b_pix, a_pix: (b_pix * a_pix) // 32 if a_pix else 0, row, a_row), base, active)\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, a_row: vec_map(\n            lambda b_pix, a_pix: (\n                (b_pix * a_pix) // 32\n                if a_pix != 0\n                else 0\n            ),\n            row,\n            a_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act: [\n            ((base_pix * act_pix) // 32) if act_pix != 0 else 0 for base_pix, act_pix in zip(row, act)\n        ],\n        base,\n        active\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: vec_map(\n            lambda pix_b, pix_a: pix_b * (pix_a // 32) if pix_a else 0,\n            row,\n            act_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return [\n        [((base_row[c] * active_row[c]) // 32) if active_row[c] != 0 else 0 for c in range(len(base_row))]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_elemwise_mul(base, matrix_map(lambda x: vec_map(lambda a, b: a * (b // 32), x, active[0]), active))\n\n\n\ndef multiply_blend_8(base, active):\n    return [\n        [(base_row[c] * active_row[c]) // 32 if active_row[c] else 0 for c in range(len(base_row))]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act: vec_map(\n            lambda pix_b, pix_a: (pix_a / 32 * pix_b) if pix_a else 0,\n            row,\n            active[0],\n        ),\n        base,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return [\n        [((base_row[i] * active_row[i]) // 32) for i in range(len(base_row)) if active_row[i] != 0]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\nreturn [\n    [((base_row[i] * active_row[i]) // 32) if active_row[i] != 0 else 0\n     for i in range(len(base_row))]\n    for base_row, active_row in zip(base, active)\n]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row: vec_map(\n            lambda pix_b, pix_a: (pix_b * pix_a) // 32 if pix_a else 0,\n            row,\n            active[0],\n        ),\n        base,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda base_row, active_row: vec_map(\n            lambda pix_b, pix_a: pix_b * pix_a // 32 if pix_a != 0 else 0,\n            base_row,\n            active_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    def pixel_operation(base_pix, active_pix):\n        return (base_pix * active_pix) // 32 if active_pix != 0 else 0\n\n    return matrix_map(\n        lambda row, active_row: vec_map(pixel_operation, row, active_row),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda base_row, active_row: vec_map(\n            lambda base_pix, active_pix: (base_pix * active_pix) // 32 if active_pix != 0 else 0,\n            base_row,\n            active_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda b_row, a_row: vec_map(\n            lambda b_pix, a_pix: ite(a_pix == 0, 0, (b_pix * a_pix) // 32),\n            b_row,\n            a_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return [[(b * a) // 32 for b, a in zip(row, act_row) if a != 0] for row, act_row in zip(base, active)]\n\n\n\ndef multiply_blend_8(base, active):\n    match base, active:\n        case [], _ | _, []:\n            return []\n        case [base_row], [active_row]:\n            return [[(base_pix * active_pix) // 32 if active_pix else 0 for base_pix, active_pix in zip(base_row, active_row)]]\n        case [base_row, *rest_base], [active_row, *rest_active]:\n            return [\n                [(base_pix * active_pix) // 32 if active_pix else 0 for base_pix, active_pix in zip(base_row, active_row)]\n                + multiply_blend_8(rest_base, rest_active)[0]\n            ]\n\n\n\ndef multiply_blend_8(base, active):\n    return [[(b * a) // 32 if a != 0 else 0 for b, a in zip(row, act_row)] for row, act_row in zip(base, active)]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_elemwise_mul(\n        base,\n        vector_where(\n            active,\n            [32] * len(active[0]),\n            lambda a, _: a // 32\n        )\n    )\n\n\n\ndef apply_operation_to_non.zero(x, a, f):\n    return [] if len(x) < 1 or len(a) < 1 else [f(x[0], a[0]), *apply_operation_to_non_zero(x[1:], a[1:], f)]\n\ndef multiply_blend_8(base, active):\n    return matrix_map(lambda row, act_row: apply_operation_to_non_zero(row, act_row, lambda pix_b, pix_a: pix_b * pix_a // 32), base, active)\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, a_row: vec_map(\n            lambda pix_b, pix_a: ite(pix_a == 0, 0, (pix_b * pix_a) // 32),\n            row,\n            a_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, a_row: vec_map(lambda pix_b, pix_a: (pix_b * pix_a) // 32 if pix_a != 0 else 0, row, a_row),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: vec_map(\n            lambda pix_b, pix_a: (pix_b * pix_a) // 32 if pix_a > 0 else 0,\n            row,\n            act_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda x, y: vec_map(\n            lambda a, b: (a * b) // 32 if b else 0,\n            x,\n            y,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    if not base or not active:\n        return []\n\n    # Recursive case\n    elif len(base[0]) > 1 or len(active[0]) > 1:\n        return [\n            [(base[0][0] * active[0][0]) // 32 if active[0][0] != 0 else 0] +\n            multiply_blend_8([base[0][1:] + active[0][1:]], base[1:] + active[1:])[0]\n        ]\n\n    # Base case: single pixel\n    else:\n        return [[(base[0][0] * active[0][0]) // 32 if active[0][0] != 0 else 0]]\n\n\n\ndef multiply_blend_8(base, active):\n    if not base:\n        return []\n    elif not base[0]:\n        return [[]]\n    else:\n        return [\n            [(base[0][0] * active[0][0]) // 32 if active[0][0] != 0 else 0] +\n            multiply_blend_8([base[0][1:] + active[0][1:]], base[1:] + active[1:])[0]\n            if len(base[0]) > 1 or len(active[0]) > 1\n            else []\n        ]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_where(base, active, lambda b_pix, a_pix: (b_pix * a_pix) // 32 if a_pix != 0 else 0)\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(lambda row, act: vec_map(lambda b, a: (b * a) // 32 if a else 0, row, act), base, active)\n\n\n\nimport operator\n\ndef multiply_blend_8(base, active):\n    return [[(operator.floordiv(operator.mul(base[row][col], active[row][col]), 32)) if active[row][col] else 0 for col in range(len(base[row]))] for row in range(len(base))]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: vec_map(\n            lambda pix_b, pix_a: pix_b * (pix_a // 32) if pix_a != 0 else 0,\n            row,\n            act_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    def pixel_operation(pix_b, pix_a):\n        return (pix_b * pix_a) // 32 if pix_a != 0 else 0\n\n    return matrix_map(\n        lambda row, active_row: reduce_map(\n            pixel_operation,\n            row,\n            active_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef reduce_map(operation, x, y):\n    return reduce(\n        lambda acc, (a, b): operation(acc, (a * b) // 32 if b != 0 else 0),\n        0,\n        zip(x, y),\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: [\n            ((row_pix * act_pix) // 32) if act_pix != 0 else 0\n            for row_pix, act_pix in zip(row, act_row)\n        ],\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(lambda x, y: vec_map(lambda a, b: (a * b) // 32 if b else 0, x, y), base, active)\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: [\n            (pix_b * pix_a) // 32 if pix_a != 0 else 0\n            for pix_b, pix_a in zip(row, act_row)\n        ],\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: vec_map(\n            lambda pix_b, pix_a: ite(pix_a > 0, pix_b * pix_a // 32, 0),\n            row,\n            act_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return [[((base_row[c] * active_row[c]) // 32) if active_row[c] != 0 else 0 for c in range(len(base_row))] for base_row, active_row in zip(base, active)]\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda b_row, a_row: vec_map(\n            lambda b_pix, a_pix: a_pix * (b_pix // 32) if a_pix != 0 else 0,\n            b_row,\n            a_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(lambda row, a_row: vec_map(lambda pix_b, pix_a: pix_b * pix_a // 32, row, a_row), base, active)\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda base_row, active_row: vec_map(\n            lambda base_pix, active_pix: (base_pix * active_pix) // 32\n            if active_pix != 0\n            else 0,\n            base_row,\n            active_row\n        ),\n        base,\n        active\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, act_row: vec_map(\n            lambda b_pix, a_pix: ite(a_pix == 0, 0, (b_pix * a_pix) // 32),\n            row,\n            act_row,\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, a_row: vec_map(\n            lambda pix_b, pix_a: (pix_b * pix_a) // 32 if pix_a else 0,\n            row,\n            vec_scalar_add(active[0][0] == 32, a_row),  # Adjust active row based on initial condition\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda row, a_row: vec_map(\n            lambda pix_b, pix_a: (pix_b * pix_a) // 32 if pix_a else 0,\n            row,\n            a_row,\n        ),\n        base,\n        [vec_scalar_add(1, active_row) for active_row in active],  # Adjust active matrix to account for initial condition\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(lambda row, act_row: reduce_map(lambda acc, (b, a): acc + (b * a) // 32 if a else acc, row, act_row) * 32, base, active)\n\n\n\ndef multiply_blend_8(base, active):\n    return [[(base_row[col] * active_row[col]) // 32 if active_row[col] != 0 else 0 for col in range(len(base_row))] for base_row, active_row in zip(base, active)]\n\n\n\ndef multiply_blend_8(base, active):\n    return [\n        [((base_row[col] * active_row[col]) // 32) if active_row[col] != 0 else 0 for col in range(len(base_row))]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\nreturn matrix_map(\n    lambda x, y: vec_map(\n        lambda a, b: (a * b) // 32,\n        x,\n        y,\n    ),\n    base,\n    active,\n)\n\n\n\ndef multiply_blend_8(base, active):\n    def pixel_operation(base_pix, active_pix):\n        return (base_pix * active_pix) // 32 if active_pix else 0\n\n    return matrix_map(lambda row, active_row: vec_map(pixel_operation, row, active_row), base, active)\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda x, y: vec_map(\n            lambda a, b: ite(b == 0, 0, (a * b) // 32),\n            x,\n            vec_map(\n                lambda a, b: b * (base[0][0] == 32),\n                x[0],\n                y[0],\n            ),\n        ),\n        base,\n        active,\n    )\n\n\n\ndef multiply_blend_8(base, active):\n    return matrix_map(\n        lambda x, y: vec_map(\n            lambda a, b: ite(b == 0, 0, (a * b) // 32),\n            x,\n            y,\n        ),\n        [[(a if b else 0) for a, b in zip(x, y)] for x, y in zip(base, active)],\n    )\n"}, {"role": "user", "content": "These generated programs are incorrect. Do not generate the same. Please generate another program."}]
