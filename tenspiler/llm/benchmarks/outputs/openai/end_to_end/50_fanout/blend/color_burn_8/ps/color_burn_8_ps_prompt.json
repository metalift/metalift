[{"role": "system", "content": "You are a helpful expert in programming languages."}, {"role": "user", "content": "\n    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function.\n    #Instructions\n    # 1. Do not use for/while loops for rewriting the function.\n    # 2. The rewritten program should just be a single return statement of the form return_var = provided_function(...)\n    # 3. Inline all the expressions. Do not use intermediate variables.\n    ```\n    #defined functions\n    from typing import Callable, List\n\n\ndef matrix_scalar_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_sub(a, matrix_x[0]), *matrix_scalar_sub(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_mul(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_mul(a, matrix_x[0]), *matrix_scalar_mul(a, matrix_x[1:])]\n    )\n\n\ndef matrix_scalar_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_div(a, matrix_x[0]), *matrix_scalar_div(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]\n    )\n\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    return lst[:end][:start]\n\n\ndef matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return matrix[:end][start:]\n\n\ndef matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    return (\n        []\n        if len(matrix) < 1\n        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]\n    )\n\n\ndef firsts(matrix: List[List[int]]) -> List[int]:\n    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]\n\n\ndef rests(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))\n\n\ndef matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:\n    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]\n\n\ndef integer_exp(n: int) -> int:\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\n\ndef reduce_max(x: List[int]) -> int:\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\n\ndef vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]\n    )\n\n\ndef matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:\n    return (\n        []\n        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)\n        else [\n            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),\n            *matrix_vec_mul(matrix_x[1:], x),\n        ]\n    )\n\n\ndef vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]\n    )\n\n\ndef matrix_elemwise_add(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_add(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_sub(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_sub(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_mul(x: List[int]) -> int:\n    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])\n\n\ndef matrix_elemwise_mul(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_mul(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_div(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vec_elemwise_div(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef vec_scalar_add(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a + x[0], *vec_scalar_add(a, x[1:])]\n\n\ndef vec_scalar_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] - a), *vec_scalar_sub(a, x[1:])]\n\n\ndef vec_scalar_mul(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [a * x[0], *vec_scalar_mul(a, x[1:])]\n\n\ndef vec_scalar_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(x[0] // a), *vec_scalar_div(a, x[1:])]\n\n\ndef scalar_vec_sub(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a - x[0]), *scalar_vec_sub(a, x[1:])]\n\n\ndef scalar_vec_div(a: int, x: List[int]) -> List[int]:\n    return [] if len(x) < 1 else [(a // x[0]), *scalar_vec_div(a, x[1:])]\n\n\ndef matrix_scalar_add(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_add(a, matrix_x[0]), *matrix_scalar_add(a, matrix_x[1:])]\n    )\n\n\ndef reduce_sum(x: List[int]) -> int:\n    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])\n\n\ndef integer_sqrt(n: int) -> int:\n    return integer_sqrt_helper((n // 2), n)\n\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    return a if cond else b\n\n\ndef col_vec(matrix: List[List[int]], col_index: int) -> List[int]:\n    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]\n\n    ```\n    ```\n    //test function\n    #include <vector>\nusing namespace std;\n\nvector<vector<int>> color_burn_8(vector<vector<int>> base, vector<vector<int>> active)\n{\n    vector<vector<int>> out;\n    int m = base.size();\n    int n = base[0].size();\n\tfor (int row = 0; row < m; row++) {\n        vector<int> row_vec;\n\t\tfor (int col = 0; col < n; col++) {\n            int pixel;\n            if (active[row][col] == 0)\n                pixel = 32;\n            else\n                pixel = 32 - (32 - base[row][col]) / active[row][col];\n            row_vec.push_back(pixel);\n\t\t}\n\t\tout.push_back(row_vec);\n\t}\n\treturn out;\n}\n\n    ```\n    "}, {"role": "assistant", "content": "\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [[min(255, 32 - (32 - x) // y) if y else 32) for x, y in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base, active):\n    return [[32 - divmod(32 - b, a)[1] * a if a else 32 for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda b, a: ite(\n            a == 0,\n            32,\n            32 - ite(b > 32, 255, (32 - b) // a) * a\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    return [[min(32, 32 - (x / y)) if y else 32) for x, y in zip(row, act_row)] for row, act_row in zip(base, active)]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda b, a: ite(\n            a == 0,\n            32,\n            ite(\n                b > 32,\n                255,\n                32 - min(31, (32 - b) // a)\n            )\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    return [\n        [32 * (1 - ((y or 1) - x / 32)) if y else 32 for x, y in zip(row_base, row_active)]\n        for row_base, row_active in zip(base, active)\n    ]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    m, n = len(base), len(base[0])\n    if m == 0 or n == 0:\n        return []\n\n    result_row = []\n    for i in range(n):\n        if active[0][i] == 0:\n            result_row.append(32)\n        else:\n            q = (32 - base[0][i]) / active[0][i]\n            q = min(255, q // 1)\n            result_row.append(32 - q * active[0][i])\n\n    return [result_row] + color_burn_8(base[1:], active[1:])\n\n\n\ndef color_burn_8(base, active):\n    return matrix_map(\n        lambda b, a: 32 * (1 - ((a or 1) - b / 32)),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda x, y: vec_len([32 - (32 - i) // j * j if j != 0 else 32] for i, j in zip(x, y)), base, active)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda x, y: ite(\n            y == 0,\n            32,\n            ite(x > 32, 255, 32 - ((32 - x) // y) * y)\n        ),\n        base,\n        active\n    )\n\n\n\ndef scale(b, a):\n    if a == 0:\n        return 32\n    elif b > 32:\n        return 255\n    else:\n        return 32 - ((32 - b) // a)\n\ndef color_burn_8(base, active):\n    return matrix_map(scale, base, active)\n\n\n\nimport numpy as np\n\ndef color_burn_8(base: np.ndarray, active: np.ndarray) -> np.ndarray:\n    return np.where(active == 0, 32, 32 - (32 - base) // active).astype(int)\n\n\n\nbase_arr = np.array(base)\nactive_arr = np.array(active)\n\nresult = color_burn_8(base_arr, active_arr)\n\n# If you want to convert the result back to a list of lists:\nresult_list = result.tolist()\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    result = [[0] * len(row) for row in base]\n    for i, row in enumerate(base):\n        for j, val in enumerate(row):\n            if active[i][j] == 0:\n                result[i][j] = 32\n            else:\n                q = (32 - val) / active[i][j]\n                result[i][j] = 32 - min(255, q * active[i][j])\n    return result\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda x, y: ite(\n            y == 0,\n            32,\n            min(32, 32 - (32 - x) // y)\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    return matrix_map(\n        lambda b, a: [0 if ai == 0 else (32 - (32 - bi) // ai) for bi, ai in zip(row_base, row_active)],\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    return matrix_map(\n        lambda x, y: ite(\n            y == 0,\n            32,\n            32 - min(255, (32 - x) // y * y)\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda x, y: min(32, 32 - (32 - x) // (y if y != 0 else 1)), base, active)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [[min(255, 32 - ((32 - b) // a if a else 0)) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [\n            32 - ((32 - x) // y) if y else 32\n            for x, y in zip(row_base, row_active)\n        ]\n        for row_base, row_active in zip(base, active)\n    ]\n\n\nUnderstood. Please provide me with the satellite number this time.\n\n\ndef burn_pixel(b, a):\n    if a == 0:\n        return 32\n    elif b > 32:\n        return 255\n    else:\n        return 32 - min(32, (32 - b) // a * a)\n\ndef color_burn_8(base, active):\n    return [[burn_pixel(x, y) for x, y in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base, active):\n    return matrix_map(lambda x, y: 32 * ((32 - x) / (y if y > 0 else 1)), base, active)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    mask = [[1 if a else 0 for a in row] for row in active]\n    exposed = [[max(0, 32 - (32 - b) // (a if a != 0 else 1)) * a for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n    return [[ brillante * m + 32 * (1 - m) for brillante, m in zip(r, mask_r)] for r, mask_r in zip(exposed, mask)]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda x, y: ite(\n            y == 0,\n            32,\n            32 - ((32 - x) // y) * y\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_where(base, matrix_plug_int(32, active), lambda x, y: ite(y == 0, 32, 32 - (32 - x) // y))\n\n\n\ndef matrix_plug_int(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda _: a, matrix_x)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda x, y: 32 * (1 - ((y or 1) - (x / 32))),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    m, n = len(base), len(base[0])\n    out = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if active[i][j] == 0:\n                out[i][j] = 32\n            else:\n                q = (32 - base[i][j]) / active[i][j]\n                out[i][j] = 32 - (q // 1) * active[i][j]\n    return out\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return base_product(base, active) if active_max(active) != 0 else base_max(base)\n\n\n\ndef base_product(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [max(0, 255 - ((base_row[i] - 32) // active_row[i] * active_row[i]))) if active_row[i] else 32 for i in range(len(base_row))]\n        for base_row, active_row in zip(base, active)\n    ] if len(base) > 0 else []\n\ndef active_max(active: List[List[int]]) -> int:\n    return max([max(row) for row in active])\n\ndef base_max(base: List[List[int]]) -> List[List[int]]:\n    return [[32] * len(base_row) for base_row in base]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [[min(255, 32 - (32 - b) // a) if a else 32 for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base, active):\n    return matrix_where(\n        base,\n        active,\n        lambda x, y: 32 if y == 0 else 32 - int((32 - x) / y) * y\n    )\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda x, y: ite(y == 0, 32, 32 - (32 - x) // y), base, active)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda x, y: vec_scalar_div(32 * (32 - x), y) if y else 32, base, active)\n\n\n\ndef color_burn_8(base, active):\n    rows = matrix_map(lambda x, y: vec_map(lambda b, a: ite(a == 0, 32, ite(b > 32, 255, 32 - ((32 - b) // a) * a)), x, y), base, active)\n    return firsts(rows)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(\n        lambda b, a: ite(\n            a == 0,\n            32,\n            32 - min(32, (32 - b) // a)\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [\n            32 - (32 - x) // y if y else 32\n            for x, y in zip(row_base, row_active)\n        ]\n        for row_base, row_active in zip(base, active)\n    ]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def transform_pixel(x, y):\n        return 32 * (1 - (y - (x // 32) if y > 0 else x) / y) if y != 0 else 32\n\n    return matrix_map(transform_pixel, base, map vec_len(active, int))\n\ndef vec_len(x: List[int], y: int) -> List[int]:\n    return [y] * len(x)\n\n\n\ndef color_burn_8(base, active):\n    def transform_transform_row(row_base, row_active):\n        return [transform_pixel(x, y) for x, y in zip(row_base, row_active)]\n\n    def transform_pixel(x, y):\n        if y == 0:\n            return 32\n        else:\n            return 32 - (32 - x) // y\n\n    return [transform_transform_row(row_base, row_active) for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base, active):\n    def pixel_transform(b, a):\n        if a == 0:\n            return 32\n        else:\n            q = (32 - b) / a\n            return 32 - (q // 1) * a\n\n    return matrix_map(pixel_transform, base, active)\n\n\n\ndef color_burn_8(base, active):\n    return [\n        [min(32, 32 - ((base_row[i] * 32) // active_row[i] if active_row[i] > 0 else 0)) for i in range(len(base_row))]\n        for base_row, active_row in zip(base, active)\n    ]\n\n\n\ndef color_burn_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            a == 0,\n            32,\n            32 - min(255, ((32 - b) * 32) // a)\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    return [[min(255, 32 * (32 - row_base[i] // row_active[i] if row_active[i] > 0 else 0)) if row_active else 32\n            for i in range(len(row_base))]\n           for row_base, row_active in zip(base, active)]\n\n\n\ndef color_burn_8(base, active):\n    def burn_row(base_row, active_row):\n        return [min(255, 32 - (32 - b) // a) if a else 32 for b, a in zip(base_row, active_row)]\n\n    return [burn_row(base_row, active_row) for base_row, active_row in zip(base, active)] if base else []\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda x, y: ite(y == 0, 32, vec_scalar_div(32 * (32 - x), y)), base, active)\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [\n        [32 - ((32 - x) // y) if y else 32 for x, y in zip(row, act_row)]\n        for row, act_row in zip(base, active)\n    ]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    if len(base) < 1 or not len(base) == len(active):\n        return []\n    else:\n        return [\n            [\n                0 if y == 0 else ((32 * (32 - x)) // y)\n                for x, y in zip(base[0], active[0])\n            ],\n            *color_burn_8(base[1:], active[1:])\n        ]\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    if not base or not active:\n        return []\n    return [\n        [32 - (32 - x) // y if y else 32 for x, y in zip(row_base, row_active)]\n        for row_base, row_active in zip(base[0], active[0])\n    ] + color_burn_8(base[1:], active[1:])\n\n\n\ndef color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return matrix_map(lambda x, y: 32 * (1 - ((y or 1) - x / 32)), base, active)\n\n\n\ndef color_burn_8(base, active):\n    return matrix_map(\n        lambda b, a: ite(\n            a == 0,\n            32,\n            ite(b > 32, 255, 32 - ((32 - b) // a))\n        ),\n        base,\n        active\n    )\n\n\n\ndef color_burn_8(base, active):\n    result = []\n    for b, a in zip(base, active):\n        row = []\n        for i, j in zip(b, a):\n            if j == 0:\n                row.append(32)\n            else:\n                q = (32 - i) / j\n                row.append(32 - (q * j) // 1)\n        result.append(row)\n    return result\n"}, {"role": "user", "content": "These generated programs are incorrect. Do not generate the same. Please generate another program."}]
