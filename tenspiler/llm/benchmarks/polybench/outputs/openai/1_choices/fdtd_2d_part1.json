[
    "The provided `fdtd_2d_part1` function iterates over a 2D grid and calculates a new value for each cell based on its current value and the value of the cell in the previous row, same column. The result is a list of lists (a matrix) where each list (row) represents the updated values for that row.\n\nTo rewrite this in functional programming form, we can use the `matrix_selection_two_args` function to iterate over the matrix without explicit loops. The selection function provided to `matrix_selection_two_args` will implement the computation done inside the inner loop of the original function. \n\nIn Python:\n\n```python\ndef fdtd_2d_part1(\n    nx: int,\n    ny: int,\n    ey: List[List[int]],\n    hz: List[List[int]]\n) -> List[List[int]]:\n    return matrix_selection_two_args(\n        ey[1:],  # start from second row\n        list_list_slice_with_length(hz, 0, nx-1),  # end at penultimate row\n        lambda e, h: e - 0.5 * (hz[i][j] - h),  # compute new value\n    )\n```\nThis function uses array slicing to align the `ey` and `hz` matrices correctly before applying the operation. The `ey` matrix starts from the second row (index 1) and the `hz` matrix ends at the penultimate row. The lambda function provided to `matrix_selection_two_args` implements the computation done inside the inner loop of the original function. \n\nNote that Python uses 0-based indexing, so `ey[i][j]` in the original C++ function corresponds to `ey[i-1][j]` in Python, and `hz[i-1][j]` corresponds to `hz[i-2][j]`. This is why we can slice `ey` from index 1 and `hz` to `nx-1` to align them correctly. \n\nPlease note that the function `matrix_selection_two_args` and `list_list_slice_with_length` are not standard Python functions, they are defined in the code you provided."
]
