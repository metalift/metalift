[
    "#rewritten function\ndef overlay_blend_8(base, active):\n    def select_two_args_arg(x, y):\n        return 2 * x * x // 255 if x < 128 else 2 * x + x - 2 * x * x // 255 - 255\n    return matrix_selection_two_args(base, active, select_two_args_arg)",
    "#rewritten function\n```python\ndef overlay_blend_8(base, active):\n    def blend_pixel(x):\n        return 2 * x + x - 2 * x * x // 255 - 255 if x >= 128 else 2 * x * x // 255\n    return matrix_vec_mul(base, vec_map(base, blend_pixel))\n```",
    "#rewritten function\nThe test function can be rewritten with the provided functions as follows:\n\n```python\ndef blend(base_pixel):\n    return 2 * base_pixel + base_pixel - 2 * base_pixel * base_pixel // 255 - 255 if base_pixel >= 128 else 2 * base_pixel * base_pixel // 255\n\ndef overlay_blend_8(base, active):\n    return matrix_selection_two_args(base, base, blend)\n```",
    "#rewritten function\n```python\ndef under_128(base, active):\n    return vec_elemwise_mul(vec_scalar_mul(2, base), vec_scalar_div(active, [255]*len(active)))\n\ndef over_128(base, active):\n    return vec_elemwise_sub(vec_elemwise_add(vec_scalar_mul(2, base), base), vec_scalar_mul(2, vec_elemwise_div(vec_elemwise_mul(base, base), [255]*len(active))))\n\ndef select(base, active):\n    return [over_128(base[i], active[i]) if base[i] >= 128 else under_128(base[i], active[i]) for i in range(len(base))]\n\ndef overlay_blend_8(base, active):\n    return selection_two_args(base, active, select)\n```\nIn the rewritten function, the provided functions `vec_elemwise_mul`, `vec_scalar_mul`, `vec_scalar_div`, `vec_elemwise_add`, `vec_elemwise_sub`, `vec_elemwise_div`, `selection_two_args` are used to solve the given task. We make use of two binary conditional functions `under_128` and `over_128` where each are used based on a specific condition of the `base` pixel value. The selection between `under_128` and `over_128` is made through the `select` function as an argument to `selection_two_args`. Thus, all computations are replaced by provided vector and scalar functions and achieved as a result of a single return statement without the need of any loops.",
    "#rewritten function\n```\ndef overlay_blend_8(base, active):\n    def blend(base):\n        if base >= 128:\n            return 2 * base + base - 2 * base * base // 255 - 255\n        else:\n            return 2 * base * base // 255\n\n    return matrix_selection_two_args(base, base, blend)\n```",
    "#rewritten function\n```\ndef overlay_blend_8(base, active):\n    return matrix_selection_two_args(\n        base, \n        active, \n        lambda x, y: 2 * x * x / 255 if x < 128 else 2 * x - 2 * x * x / 255 - 255\n    )\n```",
    "#rewritten function\n```\ndef blend_if_base_gt_128(base, active):\n    return vec_elemwise_sub(vec_scalar_mul(2, base), vec_elemwise_div(vec_elemwise_mul(2, vec_elemwise_mul(base, base)), 255))\n\ndef blend_if_base_lt_128(base, active):\n    return vec_elemwise_div(vec_elemwise_mul(2, vec_elemwise_mul(base, base)), 255)\n\ndef select_two_args_arg(base_elem, active_elem):\n    return blend_if_base_gt_128(base_elem, active_elem) if base_elem >= 128 else blend_if_base_lt_128(base_elem, active_elem)\n\ndef overlay_blend_8(base, active):\n    return matrix_selection_two_args(base, active, select_two_args_arg)\n```\nIn the code above, we've broken down the original \"overlay_blend_8\" logic into two separate vectors based on the condition whether base_elem >= 128 or not and then used a selection_function to choose which one to use based on the same original condition. These then get passed to \"matrix_selection_two_args\" function to apply on matrices \"base\" and \"active\". This function gets applied to each corresponding elements of the two matrices and uses the \"select_two_args_arg\" defined to determine which operation to perform per condition.",
    "#rewritten function\n```\ndef overlay_blend_8(base, active):\n    return matrix_selection_two_args(\n                base, \n                active, \n                lambda x, y: (\n                    2 * x + x - 2 * x * x // 255 - 255 \n                    if x >= 128 \n                    else 2 * x * x // 255\n                )\n           )\n```",
    "The test function in Example2 can be rewritten using the provided defined functions as:\n\n```python\ndef overlay_blend_8(base, active):\n    return matrix_selection_two_args(base, active, \n             lambda x, y: scalar_vec_sub(vec_scalar_mul(2, x), vec_elemwise_mul(vec_scalar_div(2, vec_elemwise_mul(x, x)), scalar_vec_div(255, vec_scalar_add(x, vec_scalar_sub(255, vec_scalar_mul(2, x))))))\n```                       \nIn the rewritten function, the matrix_selection_two_args function is used to iterate over the matrices base and active. The lambda function passed as the third argument to matrix_selection_two_args implements the logic in the original C++ function's if-else blocks for each cell in the matrices. The vec_elemwise_mul, vec_scalar_div and vec_scalar_sub defined functions are used to perform element-wise multiplication, scalar division and scalar subtraction respectively. The scalar_vec_div and vec_scalar_mul defined functions apply a scalar operation on a vector. The scalar_vec_sub defined function subtracts each element in a vector from a scalar.",
    "#rewritten function\n```python\nfrom typing import List\n\n# It is assumed vec_elemwise_mul, vec_elemwise_sub, \n# vec_scalar_mul, vec_scalar_div, vec_scalar_sub, \n# matrix_elemwise_add, matrix_selection_two_args,\n# scalar_matrix_sub have been added above as defined functions\n\ndef overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    def sub_func(a: int, b: int) -> int:\n        return 2 * a + a - 2 * a * a // 255 - 255 if a >= 128 else 2 * a * a // 255\n\n    return matrix_selection_two_args(base, active, sub_func)\n```\n\nThis function transforms the base and active matrix according to the rule specified in the given `overlay_blend_8` method. The rule is if the element of the base matrix is greater than or equal to 128, it returns the operation `2 * a + a - 2 * a * a // 255 - 255`, otherwise, it executes `2 * a * a // 255`. It is inferred from the C++ code. This rule is defined in the `sub_func`. It uses `matrix_selection_two_args` to apply this rule to all elements of the base matrix and return the result."
]
