------0 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix folgate_map

Total time to date 4.731220006942749s

------1 solution---------
To rewrite the `test` function using the provided functions and constants, without using loops, and with a single return statement, we can use recursion andMatrix operations. Here's an equivalent Python program:


Total time to date 8.507723093032837s

------2 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[element + (other_element - 32) for element, other_element in zip(base_row, active_row)] for base_row, active_row in zip(base, active)]

Total time to date 22.446595191955566s

------3 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return mat-linear_burn_8_map(base, active)

def mat-linear_burn_8_map(matrix_x: List[List[int]], matrix_y: List[List[int]]) -> List[List[int]]:
    m, n = len(matrix_x), len(matrix_x[0])
    return matrix_map(m, n, lambda i, j: (matrix_x[i][j] + matrix_y[i][j]) - 32)

def matrix_map(m: int, n: int, f: Callable[[int, int], int]) -> List[List[int]]:
    return [[f(i, j) for j in range(n)] for i in range(m)]

Total time to date 27.632596969604492s

------4 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda x, y: x + y - 32, base, active)



def matrix_map(f: Callable[[int, int], int], matrix_x: List[List[int]], matrix_y: List[List[int]]) -> List[List[int]]:
    return (
        []
        if len(matrix_x) < 1 or len(matrix_y) < 1 or not len(matrix_x[0]) == len(matrix_y[0])
        else [
            vec_map(lambda x, y: f(x, y), matrix_x[0], matrix_y[0]),
            *matrix_map(f, matrix_x[1:], matrix_y[1:]),
        ]
    )



def vec_map(f: Callable[[int, int], int], vector_x: List[int], vector_y: List[int]) -> List[int]:
    return (
        []
        if len(vector_x) < 1 or len(vector_y) < 1 or not len(vector_x) == len(vector_y)
        else [f(vector_x[0], vector_y[0]), *vec_map(f, vector_x[1:], vector_y[1:])]
    )

Total time to date 37.47455382347107s

------5 solution---------
{
"code": "from typing import Callable, List\n\ndef linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:\n    return [[(element + other_element - 32) for element, other_element in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]"
}

Total time to date 42.28978991508484s

------6 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda x, y: x + y - 32, base, active)

Total time to date 48.30103778839111s

------7 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda x, y: matrix_elemwise_add(x, matrix_scalar_add(y, -32)), base, active)

Total time to date 55.51780414581299s

------8 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda x, y: vec_map(lambda a, b: (a + b) - 32, x, y),
        base,
        active
    )

Total time to date 63.38544797897339s

------9 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []
    else:
        return [
            [(base_row[i] + active_row[i]) - 32 for i in range(len(base_row))]
            for base_row, active_row in zip(base, active)
        ]

Total time to date 71.09707999229431s

------10 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return match([[x, y] for x, y in zip(base, active)], 0)([])

def match(cases: List[List[int]], index: int) -> Callable[[List[List[int]]], List[List[int]]]:
    def helper(mat: List[List[int]]):
        if len(mat) == 0:
            return []
        else:
            row, rest = mat[0], mat[1:]
            if len(row) == 0:
                return helper(rest)
            else:
                val, rest_row = row[0], row[1:]
                new_row = [(val + other_val - 32) for other_val in rest_row]
                return [new_row] + helper(rest)
    return helper

# Usage
print(linear_burn_8([[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]))
# Output: [[-26, -25, -24], [-23, -22, -21]]

Total time to date 82.34125995635986s

------11 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def get_element(matrix, r, c):
        return matrix[r][c] if 0 <= r < len(matrix) and 0 <= c < len(matrix[0]) else 0

    def set_element(matrix, r, c, value):
        if 0 <= r < len(matrix) and 0 <= c < len(matrix[0]):
            matrix[r][c] = value

    m, n = len(base), len(base[0])
    result = [[0 for _ in range(n)] for _ in range(m)]

    for r in range(m):
        for c in range(n):
            result[r][c] = get_element(base, r, c) + get_element(active, r, c) - 32

    return result

Total time to date 91.90936613082886s

------12 solution---------
def linear_burn_8(base, active):
    return [
        [(b + a) - 32 for b, a in zip(row_base, row_active)]
        for row_base, row_active in zip(base, active)
    ]

Total time to date 99.1071879863739s

------13 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []
    else:
        return [
            [(base[0][i] + active[0][i]) - 32 for i in range(len(base[0]))]
            + linear_burn_8(base[1:], active[1:])
            if base and active
            else []
        ]

Total time to date 107.33554577827454s

------14 solution---------
def linear_burn_8(base, active):
    return matrix_map(lambda x, y: vec_map(lambda a, b: (a + b) - 32, x, y), base, active)

Total time to date 113.4888551235199s

------15 solution---------
from typing import List
from functools import reduce

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def add_subtractScalarFromRow(row_base: List[int], row_active: List[int]) -> List[int]:
        return [element + other_element - 32 for element, other_element in zip(row_base, row_active)]

    def rowMap(rows: List[List[int]]) -> List[List[int]]:
        return [reduce(add_subtractScalarFromRow, row_pairs) for row_pairs in zip(*rows)]

    return rowMap(zip(base, active))

Total time to date 123.41893410682678s

------16 solution---------
def linear_burn_8(base, active):
    return matrix_map(
        lambda bx, ax: vec_map(
            lambda b, a: (b + a) - 32,
            bx,
            ax
        ),
        base,
        active
    )



def matrix_map(f, matrix_x, matrix_y):
    return (
        [] if len(matrix_x) < 1 else [
            f(matrix_x[0], matrix_y[0]),
            *matrix_map(f, matrix_x[1:], matrix_y[1:])
        ]
    )

def vec_map(f, vector_x, vector_y):
    return (
        [] if len(vector_x) < 1 else [
            f(vector_x[0], vector_y[0]),
            *vec_map(f, vector_x[1:], vector_y[1:])
        ]
    )

Total time to date 134.20458388328552s

------17 solution---------
def linear_burn_8(base, active):
    return [[(b + a) - 32 for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]

Total time to date 140.3781168460846s

------18 solution---------
import numpy as np

def linear_burn_8(base, active):
    return (base + active - 32).tolist()

Total time to date 150.565358877182s

------19 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(b + a) - 32 for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]

Total time to date 158.23948693275452s

------20 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []
    elif not base[0] or not active[0]:
        return []
    else:
        first_row_base, *rest_base = base
        first_row_active, *rest_active = active
        return [
            [(first_row_base[i] + first_row_active[i]) - 32 for i in range(len(first_row_base))]
            + linear_burn_8(rest_base, rest_active)[0]
            if rest_base and rest_active
            else []
        ]

Total time to date 167.25793600082397s

------21 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(b + a - 32) for b, a in zip(row_base, row_active)]
            for row_base, row_active in zip(base, active)] if base and active else []

Total time to date 174.6733419895172s

------22 solution---------
def linear_burn_8(base, active):
    return [
        [
            matrix_scalar_add(x, y) - 32
            for x, y in zip(row_base, row_active)
        ]
        for row_base, row_active in zip(base, active)
    ]

Total time to date 181.56228590011597s

------23 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(b + a - 32) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]

Total time to date 189.40084791183472s

------24 solution---------
def linear_burn_8(base, active):
    return [
        vector_where(base[row], active[row], lambda b, a: b + a - 32)
        for row in range(len(base))
    ]

Total time to date 196.65789890289307s

------25 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda x, y: vec_map(lambda a, b: (a + b) - 32, x, y),
        base,
        active
    )

Total time to date 206.6399748325348s

------26 solution---------
def linear_burn_8(base, active):
    return matrix_where(
        base,
        active,
        lambda b, a: b + a - 32 if b is not None and a is not None else None,
    )

Total time to date 214.41358590126038s

------27 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(b + a - 32) for b, a in zip(row_base, row_active)] for row_base, row_active in zip(base, active)]

Total time to date 221.91766595840454s

------28 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        matrix_elemwise_add(base, matrix_scalar_add(active, -32)),
        lambda _: True
    )

Total time to date 230.63741898536682s

------29 solution---------
import numpy as np

def linear_burn_8(base, active):
    return (np.array(base) + np.array(active) - 32).tolist()

Total time to date 240.76294088363647s

------30 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(bx + ax) - 32 for bx, ax in zip(rb, ra)] for rb, ra in zip(base, active)]

Total time to date 248.7805609703064s

------31 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []
    else:
        return [
            [(base_row[i] + active_row[i]) - 32 for i in range(len(base_row))]
            for base_row, active_row in zip(base[0], active[0])
        ] + linear_burn_8(base[1:], active[1:]) if base and active else []

Total time to date 257.3948538303375s

------34 solution---------
import numpy as np

def linear_burn_8(base, active):
    return (base + active - 32).astype(int).tolist()



from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return list(map(lambda row_base, row_active: [(b + a) - 32 for b, a in zip(row_base, row_active)], base, active))

Total time to date 281.96175599098206s

------35 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []

    first_row_base, *rest_base = base
    first_row_active, *rest_active = active

    if not first_row_base or not first_row_active:
        return []

    return [
        [(first_row_base[i] + first_row_active[i]) - 32 for i in range(len(first_row_base))]
        + linear_burn_8(rest_base, rest_active)[0]
    ]

Total time to date 291.4070990085602s

------37 solution---------
from typing import List, Callable

# ... ( existing functions )

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def row_burn(base_row: List[int], active_row: List[int]) -> List[int]:
        if not base_row or not active_row:
            return []
        else:
            return [
                (base_row[0] + active_row[0]) - 32
                + row_burn(base_row[1:], active_row[1:])
                if base_row and active_row
                else []
            ]

    def combine_rows(result: List[List[int]], new_row: List[int]) -> List[List[int]]:
        return result + [new_row] if result else [new_row]

    return combine_rows(
        combine_rows(result, row_burn(base[0], active[0]))
        if base and active
        else [],
        linear_burn_8(base[1:], active[1:])
        if base and active
        else []
    ) if base and active else []

Total time to date 309.4166820049286s

------38 solution---------
def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda x, y: vec_elemwise_add(x, vec_scalar_add(y, -32)), base, active)

Total time to date 317.9988360404968s

------39 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []

    first_row_base, *rest_base = base
    first_row_active, *rest_active = active

    if not first_row_base or not first_row_active:
        return []

    result = [
        [(first_row_base[i] + first_row_active[i]) - 32 for i in range(len(first_row_base))]
        + linear_burn_8(rest_base, rest_active)[0]
        if rest_base and rest_active
        else []
    ]

    return result if result else []

Total time to date 328.5075798034668s

------40 solution---------
import numpy as np

def linear_burn_8(base, active):
    return (base + active - 32).astype(int).tolist()

Total time to date 338.87541675567627s

------41 solution---------
def linear_burn_8(base, active):
    return list(map(
        lambda row_base, row_active: [(b + a - 32) for b, a in zip(row_base, row_active)],
        base,
        active
    ))

Total time to date 347.8078029155731s

------42 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def burn_row(row_base: List[int], row_active: List[int]) -> List[int]:
        return [(b + a - 32) for b, a in zip(row_base, row_active)]

    def combine_results(result: List[List[int]], new_row: List[int]) -> List[List[int]]:
        return result + [new_row] if result else [new_row]

    return combine_results(
        combine_results(result, burn_row(base[0], active[0]))
        if base and active
        else [],
        linear_burn_8(base[1:], active[1:])
        if base and active
        else []
    ) if base and active else []

Total time to date 358.72789001464844s

------44 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [
        [base_row[i] + active_row[i] - 32 for i in range(len(base_row))]
        for base_row, active_row in zip(base, active)
    ]

Total time to date 374.1679391860962s

------46 solution---------
def linear_burn_8(base, active):
    return [
        [(b + a - 32) if i < j else (b - a) for i, (b, a) in enumerate(zip(row_base, row_active))]
        for j, (row_base, row_active) in enumerate(zip(base, active))
    ]

Total time to date 390.50308895111084s

------47 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base or not active:
        return []

    return [
        [(b + a) - 32 for b, a in zip(row_base, row_active)]
        for row_base, row_active in zip(base[0], active[0])
    ] + linear_burn_8(base[1:], active[1:]) if base and active else []

Total time to date 400.3280568122864s

------48 solution---------
from typing import List

def linear_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(b + a - 32) for b, a in row_pair] for row_pair in zip(base, active)]

Total time to date 408.9026701450348s
