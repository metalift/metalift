------0 solution---------
def dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:
    return [
        [
            active[row][col] if opacity - (rand_cons % 100 + 1) / 100 >= 0 else base[row][col]
            for col in range(len(base[0]))
        ]
        for row in range(len(base))
    ]

Total time to date 13.203236103057861s

------1 solution---------
def dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:
    return [
        vec_map(
            vec_slice(
                matrix_row_slice(base if opacity - (rand_cons % 100 + 1) / 100 < 0 else active, row, row + 1),
                0,
                len(base[0])
            ),
            lambda pixel: matrix_firsts([pixel])[0]
        )
        for row in range(len(base))
    ]

Total time to date 19.167251348495483s

------2 solution---------
def dissolve_blend_8(base, active, opacity, rand_cons):
    return matrix_map(lambda row:
                      vec_map(lambda col:
                              ite(opacity - (rand_cons % 100 + 1) / 100 >= 0,
                                  active[row][col],
                                  base[row][col]), row), base)

Total time to date 25.239100217819214s

------3 solution---------
def dissolve_blend_8(base, active, opacity, rand_cons):
    blend = lambda x, y: ite(opacity - (rand_cons % 100 + 1) / 100 >= 0, y, x)
    return matrix_map(blend, active, base)

Total time to date 31.310368061065674s

------4 solution---------
def blend_pixel(base_pixel, active_pixel, opacity, rand_val):
    return active_pixel if opacity - rand_val >= 0 else base_pixel

def dissolve_blend_8(base, active, opacity, rand_cons):
    blend = partial(blend_pixel, opacity=opacity, rand_cons=rand_cons)
    return matrix_map(
        lambda row: vec_map(blend, row),
        active
    )

Total time to date 38.889503955841064s

------5 solution---------
def dissolve_blend_8(base, active, opacity, rand_cons):
    return [[
        active[row][col] if opacity - (rand_cons % 100 + 1) / 100 >= 0 else base[row][col]
        for col in range(len(base[0]))
    ] for row in range(len(base))]

Total time to date 45.42558526992798s

------6 solution---------Understood. Here's another approach using Matrix Exponentiation by Squaring and Karatsubaalgorithm for matrix multiplication to optimize the `dissolve_blend_8` function. This version also avoids recursion and uses a list comprehension with the `map` function.

```python
import random
from functools import partial

def karatsuba_mul(a, b):
    n = max(len(a), len(b))
    if n <= 1:
        return [[a[0][0] * b[0][0]]]

    m = n // 2
    a11, a12, a21, a22 = matrix_split(a, m)
    b11, b12, b21, b22 = matrix_split(b, m)

    p1 = karatsuba_mul(a11, matrix_sub(b12, b22))
    p2 = karatsuba_mul(matrix_add(a12, a22), b21)
    p3 = karatsuba_mul(matrix_add(a11, a22), matrix_add(b11, b22))

    c11 = matrix_add(matrix_add(p1, matrix_scalar_mul(2, p2)), matrix_scalar_mul(-1, p3))
    c12 = matrix_add(p2, p3)
    c21 = matrix_add(p2, p3)
    c22 = matrix_add(matrix_sub(c11, p1), matrix_scalar_mul(2, p2))

    return matrix_concat(c11, c12, c21, c22)

def matrix_common_function(M, f):
    return [[f(M[row][col]) for col in range(len(M[0]))] for row in range(len(M))]

def matrix_map(f, *M):
    if len(M) == 1:
        return matrix_common_function(M[0], f)
    else:
        return matrix_mul(matrix_map(f, *M[:-1]), M[-1])

def matrix_elementwise_op(op, M, N):
    return matrix_map(lambda x, y: op(x, y), M, N)

def dissolve_blend_8(base, active, opacity, rand_cons):
    blend_func = partial(lambda pixel, opacity, rand_val: pixel if opacity - rand_val >= 0 else pixel,
Total time to date 57.03952932357788s

------7 solution---------
def dissolve_blend_8(base, active, opacity, rand_cons):
    return [
        [
            active[row][col] if opacity - (rand_cons % 100 + 1) / 100 >= 0 else base[row][col]
            for col, val in enumerate(zip(base[row], active[row]))
        ]
        for row in range(len(base))
    ]

Total time to date 64.49023628234863s

------8 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    rand_val = np.random.rand(base.shape[0], base.shape[1]) * 100
    mask = (opacity - rand_val) >= 0
    return np.where(mask, active, base)

Total time to date 73.20011901855469s

------9 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random values for each pixel
    rand_val = np.random.rand(base.shape[0], base.shape[1]) * 100

    # Create a mask for each pixel based on the opaque condition
    mask = opacity - rand_val >= 0

    # Use np.where to blend active and base images based on the mask
    blended = np.where(mask[..., np.newaxis], active, base)

    return blended

Total time to date 84.08617424964905s

------10 solution---------
def dissolve_blend_8(base, active, opacity, rand_cons):
    return [
        [
            active_row[col] if opacity - (rand_cons % 100 + 1) / 100 >= 0 else base_row[col]
            for col, (base_row, active_row) in enumerate(zip(base, active))
        ]
        for _ in range(len(base))
    ]

Total time to date 91.53368401527405s

------11 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    rand_mask = np.random.rand(*base.shape) * 100 < (opacity * 100 - rand_cons)
    return np.where(rand_mask[..., None], active, base)

Total time to date 99.37087321281433s

------12 solution---------
#include <vector>
#include <utility>
#include <algorithm>
#include <ctime>
#include <cstdlib>
#include <random>

std::vector<std::vector<int>> dissolve_blend_8(std::vector<std::vector<int>>& base,
                                              std::vector<std::vector<int>>& active,
                                              int opacity,
                                              int rand_cons) {
    std::default_random_engine generator;
    std::uniform_int_distribution<int> distribution(1, 100);
    std::vector<std::vector<int>> result(base.size(), std::vector<int>(base[0].size()));

    for (auto& row : result) {
        for (auto& value : row) {
            value = (distribution(generator) + rand_cons <= opacity)
                ? active[row][value]
                : base[row][value];
        }
    }

    return result;
}

Total time to date 107.58888125419617s

------13 solution---------
import random

def dissolve_blend_8(base, active, opacity, rand_cons):
    rows, cols = len(base), len(base[0])
    result = [[0] * cols for _ in range(rows)]

    while rows:
        row = result.pop(0)
        if not rows:
            break

        cols = len(result[0])
        while cols:
            col = cols - 1
            rand_val = random.randint(0, rand_cons) / rand_cons

            if opacity - rand_val >= 0:
                row[col] = active.pop(0)[col]
            else:
                row[col] = base.pop(0)[col]

            if not cols:
                break

        result.append(row)

    return result

Total time to date 117.66636896133423s

------14 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random values between 0 and 1 with shape matching the base image
    rand_val = np.random.rand(*base.shape)

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = opacity - rand_val * 100 >= 0

    # Use NumPy's advanced indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 127.64309811592102s

------15 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = opacity - rand_val * 100 >= 0

    # Use NumPy's indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 138.07232308387756s

------16 solution---------
import numpy as np

def generate_random_mask(rand_cons, opacity, shape):
    rand_val = np.random.rand(*shape) * 100
    mask = opacity - rand_val >= 0
    return mask

def blend_pixels(base, active, mask):
    blended = np.where(mask[..., None], active, base)
    return blended

def dissolve_blend_8(base, active, opacity, rand_cons):
    mask = generate_random_mask(rand_cons, opacity, base.shape)
    blended = blend_pixels(base, active, mask)
    return blended.tolist()

# Example usage:
base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
active = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])
opacity = 70
rand_cons = 30

result = dissolve_blend_8(base, active, opacity, rand_cons)
print(result)

Total time to date 151.62926530838013s

------17 solution---------
def blend_vector(base, active, opacity, rand_cons):
    return vec_map(lambda x, y: ite(opacity - (rand-cons % 100 + 1) / 100 >= 0, y, x), base, active)

def dissolve_blend_8(base, active, opacity, rand_cons):
    return matrix_map(lambda row: blend_vector(row, active[row], opacity, rand_cons), base)

Total time to date 161.00455904006958s

------18 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Create a condition where opacity - rand_val is greater than or equal to 0
    condition = opacity - rand_val * 100 >= 0

    # Use NumPy's advanced indexing to blend active and base images based on the condition
    blended = np.where(condition[..., None], active, base)

    return blended.tolist()

Total time to date 170.68924117088318s

------19 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    rand_val = np.random.rand(*base.shape)
    return np.where((opacity * 100 - rand_val * 100 - rand_cons) >= 0, active, base)

Total time to date 178.3300621509552s

------20 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to numpy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values for each pixel
    rand_val = np.random.rand(base.shape[0], base.shape[1]) * 100

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = opacity - rand_val >= 0

    # Use the mask to blend active and base images
    blended = np.where(mask[..., None], active, base)

    # Convert the blended array back to a list of lists
    blended_list = blended.tolist()

    return blended_list

Total time to date 190.75140118598938s

------22 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Calculate the random consistency factor
    rand_cons_factor = rand_cons / 100

    # Create a condition where opacity - (rand_val * 100 + rand_cons) is greater than or equal to 0
    condition = opacity - (rand_val * 100 + rand_cons_factor) >= 0

    # Use NumPy's advanced indexing to blend active and base images based on the condition
    blended = np.where(condition[..., None], active, base)

    return blended.tolist()

Total time to date 209.50674200057983s

------23 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate inputs
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers")
    if not all(len(x) == len(base[0]) for x in base):
        raise ValueError("Base matrix has inconsistent row lengths")
    if not all(len(x) == len(active[0]) for x in active):
        raise ValueError("Active matrix has inconsistent row lengths")
    if not all(len(x) == len(y) for x, y in zip(base, active)):
        raise ValueError("Base and active matrices must have matching dimensions")
    if not 0 <= opacity <= 100:
        raise ValueError("Opacity must be between 0 and 100")
    if not 0 <= rand_cons <= 100:
        raise ValueError("Random consistency must be between 0 and 100")

    # Convert lists to numpy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values for each pixel with the given consistency
    rand_val = np.random.rand(*base.shape) * rand_cons

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = opacity - rand_val * (100 / rand_cons) >= 0

    # Use NumPy's advanced indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 223.81925296783447s

------24 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random_cons consistent random values between 0 and 100
    rand_val = np.random.rand(*base.shape) * (rand_cons / 100)

    # Create a condition where opacity - rand_val is greater than or equal to 0
    condition = opacity - rand_val >= 0

    # Use NumPy's advanced indexing with the condition to blend active and base images
    blended = np.where(condition[..., None], active, base)

    return blended.tolist()



base = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
active = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
opacity = 70
rand_cons = 30

result = dissolve_blend_8(base, active, opacity, rand_cons)
print(result)

Total time to date 236.8064329624176s

------25 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random values between 0 and 1 with shape matching the base image
    rand_val = np.random.rand(*base.shape)

    # Calculate the weighted opacity for each pixel
    weight = (opacity - rand_val * 100) / 100

    # Perform weighted blending of active and base images using NumPy's advanced indexing
    blended = weight[:, :, None] * active + (1 - weight)[:, :, None] * base

    return blended.tolist()

Total time to date 250.4232361316681s

------26 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert inputs to numpy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values in the range [0, rand_cons]
    rand_val = np.random.rand(*base.shape) * rand_cons

    # Create a mask where (opacity - rand_val) / rand_cons is greater than or equal to 0
    mask = (opacity - rand_val) / rand_cons >= 0

    # Use NumPy's advanced indexing with the mask to blend active and base images
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 264.1468551158905s

------27 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to NumPy arrays
    base, active = np.array(base), np.array(active)

    # Generate random values between 0 and 1 with the same shape as the input matrices
    rand_val = np.random.rand(*base.shape)

    # Calculate the random consistency factor
    rand_cons_factor = rand_cons / 100

    # Create a mask where opacity - (rand_val * 100 + rand_cons) is greater than or equal to 0
    mask = opacity - (rand_val * 100 + rand_cons_factor) >= 0

    # Use NumPy's indexing to blend active and base images based on the mask
    # The [..., None] broadcast dimension allows us to perform the operation element-wise
    blended = np.where(mask[..., None], active, base)

    # Convert the output array back to a list of lists
    blended_list = blended.tolist()

    return blended_list

Total time to date 280.5369961261749s

------28 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to NumPy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random mask based on opacity and rand_cons
    rand_mask = np.random.rand(*base.shape) * 100 <= opacity - rand_cons

    # Perform element-wise blending using the mask
    blended = np.where(rand_mask[..., None], active, base)

    return blended.tolist()



base = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
active = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
opacity = 70
rand_cons = 30

result = dissolve_blend_8(base, active, opacity, rand_cons)
print(result)

Total time to date 294.0337772369385s

------29 solution---------
import numpy as np
import random

def blend_pixels(base, active, opacity, rand_cons):
    rows, cols = base.shape
    mask = np.array([[random.randint(0, rand_cons) <= opacity for _ in range(cols)] for _ in range(rows)])
    return np.where(mask, active, base)

def dissolve_blend_8(base, active, opacity, rand_cons):
    validation = lambda x, y: len(x) == len(y) == len(base)
    if not (validation(base, active) and 0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Invalid input arguments")
    return blend_pixels(base, active, opacity, rand_cons).tolist()



base = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
active = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])
opacity = 70
rand_cons = 30

result = dissolve_blend_8(base, active, opacity, rand_cons)
print(result)

Total time to date 311.3024911880493s

------30 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to numpy arrays
    base, active = np.array(base), np.array(active)

    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Create a condition where opacity - rand_val is greater than or equal to 0
    condition = opacity - rand_val * 100 >= 0

    # Use NumPy's choose function to blend active and base images based on the condition
    blended = np.choose(condition[..., None], (active, base))

    return blended.tolist()

Total time to date 324.3234372138977s

------31 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate input arguments
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be between 0 and 100")
    if not (isinstance(base, list) and all(isinstance(row, list) and all(isinstance(val, int) for val in row) for row in base)):
        raise TypeError("Base matrix must be a list of lists of integers")
    if not (isinstance(active, list) and all(isinstance(row, list) and all(isinstance(val, int) for val in row) for row in active)):
        raise TypeError("Active matrix must be a list of lists of integers")
    if len(base) != len(active) or any(len(row) != len(base[0]) for row in base + active):
        raise ValueError("Base and active matrices must have the same dimensions")

    # Convert input lists to NumPy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Scale and clip the random values to the range [0, rand_cons]
    rand_val = np.clip(rand_val * (rand_cons / 100), 0, rand_cons / 100)

    # Calculate the probability of using the active pixel for each pixel in the base image
    prob = (opacity - rand_val) / 100

    # Use NumPy's advanced indexing to blend the base and active images based on the probability
    blended = np.where(np.random.rand(*base.shape) < prob, active, base)

    # Convert the output array back to a list of lists
    blended_list = blended.tolist()

    return blended_list

Total time to date 341.2878930568695s

------32 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Generate random mask with given consistency
    mask = np.random.rand(*base.shape) < (opacity - rand_cons) / 100

    # Perform element-wise blending based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 351.57008934020996s

------33 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Input validation
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and rand_cons must be between 0 and 100")

    if not (isinstance(base, list) and all(isinstance(row, list) for row in base) and all(isinstance(val, int) for row in base for val in row)):
        raise TypeError("Base matrix must be a list of lists of integers")

    if not (isinstance(active, list) and all(isinstance(row, list) for row in active) and all(isinstance(val, int) for row in active for val in row)):
        raise TypeError("Active matrix must be a list of lists of integers")

    if len(base) != len(active) or len(base[0]) != len(active[0]):
        raise ValueError("Base and active matrices must have the same dimensions")

    # Convert input lists to numpy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Calculate the probability of using the active pixel for each pixel in the base image
    prob = (opacity - (rand_val * 100)) / (100 - rand_cons)

    # Use numpy's random choice function to determine whether to use the active or base pixel for each pixel
    mask = np.random.choice([True, False], size=base.shape, p=[prob, 1-prob])

    # Use advanced indexing to blend the active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 370.69704604148865s

------34 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers.")
    if not len(base) == len(active) or any(len(x) != len(active[0]) for x in base):
        raise ValueError("Base and active matrices must have the same dimensions.")

    # Convert lists to NumPy arrays for efficient computations
    base = np.array(base)
    active = np.array(active)

    # Generate random values with the given consistency
    rand_val = np.random.rand(*base.shape) * (rand_cons / 100)

    # Calculate the probability where opacity - rand_val is greater than or equal to 0
    prob = (opacity - rand_val) / (100 - rand_cons)

    # Use NumPy's random choice with the calculated probability to create a mask
    mask = np.random.choice([True, False], size=base.shape, p=[prob, 1-prob])

    # Blend active and base images based on the mask
    blended = np.where(mask, active, base)

    return blended.tolist()

Total time to date 385.5577850341797s

------35 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Input validation
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of lists of integers")
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base + active):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to numpy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values with the given consistency
    rand_val = np.random.rand(*base.shape) * rand_cons

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = np.extract(opacity - rand_val >= 0, base)

    # Use advanced indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 399.3777060508728s

------36 solution---------
import numpy as np
import random

def generate_random_values(shape, rand_cons):
    return random.choices(population=range(100), weights=[rand_cons] * 100 + [1] * (100 - rand_cons), k=shape[0] * shape[1]).reshape(shape)

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate input types and dimensions
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of lists of integers")
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base + active):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to numpy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values with the given consistency
    rand_val = generate_random_values(base.shape, rand_cons)

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = opacity - rand_val >= 0

    # Use advanced indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 415.9812421798706s

------37 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate input types and dimensions
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers")
    if len(base) != len(active) or any(len(x) != len(active[0]) for x in base):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to NumPy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values with the given consistency
    rand_val = np.random.randint(0, rand_cons, size=base.shape) / rand_cons * 100

    # Create a condition where opacity - rand_val is greater than or equal to 0
    condition = opacity - rand_val

    # Use NumPy's vectorized element-wise operation to blend active and base images based on the condition
    blended = np.where(condition >= 0, active, base)

    return blended.tolist()

Total time to date 433.9759600162506s

------38 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to NumPy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Scale the random values to the range 0 to rand_cons
    rand_val = rand_val * rand_cons

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = opacity - rand_val >= 0

    # Use NumPy's broadcasting and advanced indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    # Convert the output array back to a list of lists
    blended_list = blended.tolist()

    return blended_list

Total time to date 447.48833203315735s

------39 solution---------
from typing import Callable, List

def dissolve_blend_8(base: List[List[int]], active: List[List[int]], opacity: int, rand_cons: int) -> List[List[int]]:
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base + active):
        raise ValueError("Base and active matrices must have the same dimensions")

    rand_val = vec_map(lambda _: rand_cons % 100 + 1 if rand_cons else 100, range(len(base[0])))
    prob = (opacity - rand_val) / 100

    return matrix_where(
        matrix_x=base,
        matrix_y=active,
        condition=lambda x, y: np.random.rand() < prob,
    )

Total time to date 459.90823125839233s

------40 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to NumPy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Calculate the random consistency factor
    rand_cons_factor = rand_cons / 100

    # Create a condition where opacity - (rand_val * 100 + rand_cons) is greater than or equal to 0
    condition = opacity - (rand_val * 100 + rand_cons_factor) >= 0

    # Use NumPy's advanced indexing with the condition to blend active and base images
    # The [..., None] broadcasts the condition for the third axis (i.e., for each pixel)
    blended = np.where(condition[..., None], active, base)

    return blended.tolist()

Total time to date 474.1075761318207s

------41 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    if not isinstance(base, list) or not isinstance(active, list) or len(base) != len(active) or any(len(row) != len(base[0]) for row in base + active):
        raise ValueError("Invalid input format")
    if not 0 <= opacity <= 100 or not 0 <= rand_cons <= 100:
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert inputs to numpy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random values with shape matching the input matrices
    rand_val = np.random.rand(*base.shape) * (rand_cons / 100)

    # Calculate the probability of using the active pixel for each pixel in the base image
    prob = (opacity - rand_val) / (100 - rand_cons)

    # Use NumPy's random choice with the calculated probability to blend active and base images
    blended = np.random.choice([base, active], p=[1 - prob, prob])

    return blended.tolist()

Total time to date 489.2215402126312s

------42 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Input validation
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers")
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base + active):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to numpy arrays
    base = np.array(base)
    active = np.array(active)

    # Generate random validity values between 0 and 1 with the same shape as the base image
    validity = np.random.rand(*base.shape)

    # Calculate the random consistency factor
    rand_cons_factor = rand_cons / 100

    # Create a condition where opacity - (validity * 100 + rand_cons) is greater than or equal to 0
    condition = opacity - (validity * 100 + rand_cons_factor)

    # Use NumPy's advanced indexing with the condition to blend active and base images
    blended = np.where(condition >= 0, active, base)

    return blended.tolist()

Total time to date 511.8127541542053s

------43 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate input types and dimensions
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers")
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base + active):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to NumPy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and rand_cons with the same shape as the base image
    rand_val = np.random.randint(0, rand_cons, size=base.shape)

    # Create a condition where opacity - rand_val is greater than or equal to 0
    condition = opacity - rand_val

    # Use NumPy's advanced indexing to blend active and base images based on the condition
    blended = np.where(condition[..., None], active, base)

    return blended.tolist()

Total time to date 529.3738601207733s

------44 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate input types and dimensions
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers")
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to NumPy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and 1 with the same shape as the base image
    rand_val = np.random.rand(*base.shape)

    # Scale random values to be within the range of rand_cons and opacity
    rand_val = rand_val * rand_cons / 100

    # Calculate the probability of using the active pixel for each pixel in the base image
    prob = (opacity - rand_val) / (100 - rand_cons)

    # Use NumPy's random.choice function to blend active and base images based on the calculated probabilities
    blended = np.random.choice([base, active], p=[1 - prob, prob])

    return blended.tolist()

Total time to date 546.8891062736511s

------45 solution---------I understand. Can you tell me what the incorrect part of the previous programs was? And what aspects of the `test` function they did not correctly capture? What changes do you want me to make in the new program?
Total time to date 555.1939260959625s

------46 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Validate input types and dimensions
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of integers")
    if len(base) != len(active) or any(len(x) != len(base[0]) for x in base):
        raise ValueError("Base and active matrices must have the same dimensions")
    if not (0 <= opacity <= 100 and 0 <= rand_cons <= 100):
        raise ValueError("Opacity and random consistency must be in range [0, 100]")

    # Convert input lists to NumPy arrays for efficient operations
    base = np.array(base)
    active = np.array(active)

    # Generate random values between 0 and 100 with the given consistency
    rand_val = np.random.randint(0, rand_cons, size=base.shape)

    # Create a mask where opacity - rand_val is greater than or equal to 0
    mask = np.where(opacity - rand_val >= 0)

    # Use NumPy's vectorized advanced indexing to blend active and base images based on the mask
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

Total time to date 572.18399310112s

------47 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Input validation
    if not all(isinstance(x, list) and all(isinstance(y, int) for y in x) for x in (base, active)):
        raise TypeError("Base and active matrices must be lists of lists of integers")
    if not 0 <= opacity <= 100 or not 0 <= rand_cons <= 100:
        raise ValueError("Opacity and random constants must be in range [0, 100]")

    # Convert input lists to NumPy arrays
    base = np.array(base)
    active = np.array(active)

    # Calculate the probability of using the active pixel for each pixel in the base image
    prob = (opacity - np.random.randint(0, rand_cons + 1, size=(base.shape)) / 100

    # Use NumPy's random choice to blend active and base images based on the calculated probabilities
    blended = np.random.choice([base, active], size=base.shape, p=[1 - prob, prob])

    return blended.tolist()

Total time to date 587.1573162078857s

------48 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    # Convert input lists to numpy arrays
    base = np.array(base, dtype=np.int32)
    active = np.array(active, dtype=np.int32)

    # Generate random values between 0 and rand_cons with the same shape as the base image
    rand_val = np.random.randint(0, rand_cons, size=base.shape)

    # Calculate the probability of using the active pixel for each pixel in the base image
    prob = (opacity - rand_val) / (100 - rand_cons)

    # Use NumPy's random.choice function to blend active and base images based on the calculated probabilities
    blended = np.random.choice([base, active], p=[1 - prob, prob])

    return blended.tolist()

Total time to date 602.6681263446808s

------49 solution---------
import numpy as np

def dissolve_blend_8(base, active, opacity, rand_cons):
    if not (isinstance(base, list) and all(isinstance(row, list) and all(isinstance(val, int) for val in row) for row in base)):
        raise TypeError(f"Base matrix must be a list of lists of integers. Got {type(base)}")
    if not (isinstance(active, list) and all(isinstance(row, list) and all(isinstance(val, int) for val in row) for row in active)):
        raise TypeError(f"Active matrix must be a list of lists of integers. Got {type(active)}")
    if not all(len(row) == len(base[0])) or len(base) != len(active):
        raise ValueError(f"Base and active matrices must have the same dimensions. Got {len(base[0])} vs {len(active[0])}, {len(base)} vs {len(active)}")
    if not (0 <= opacity <= 100) or not (0 <= rand_cons <= 100):
        raise ValueError(f"Opacity and random consistency must be in range [0, 100]. Got opacity={opacity}, rand_cons={rand_cons}")

    base, active = np.array(base), np.array(active)
    random_values = np.random.rand(*base.shape) * (100 - rand_cons)
    mask = (opacity - random_values) >= 0
    blended = np.where(mask[..., None], active, base)

    return blended.tolist()

# Example usage:
base = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
active = [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
opacity = 70
rand_cons = 30

print(dissolve_blend_8(base, active, opacity, rand_cons))

Total time to date 621.7117750644684s
