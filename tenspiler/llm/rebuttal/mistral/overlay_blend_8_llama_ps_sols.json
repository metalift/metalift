------0 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    m, n = len(base), len(base[0])
    return matrix_map(lambda row: vec_map(lambda col: ite(
        16 <= base[row][col],
        2 * base[row][col] + base[row][col] * (1 - 2 * base[row][col] // 32) - 32,
        2 * base[row][col] * base[row][col] // 32
    ), range(n)), range(m))

Total time to date 17.95930027961731s

------1 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base:
        return []

    blend_func = lambda x: 2 * x * (1 - x // 16) - 32 if x >= 16 else x * x // 16
    return [[blend_func(base[row][col]) for col in range(len(base[0]))] for row in range(len(base))] + overlay_blend_8(base[1:], active[1:])

Total time to date 26.023365259170532s

------2 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r: vec_map(
            lambda c: ite(
                base[r][c] >= 16,
                2 * base[r][c] + base[r][c] - 2 * base[r][c] // 32 - 32,
                2 * base[r][c] * base[r][c] // 32
            ),
            range(len(base[0]))
        ),
        range(len(base))
    )

Total time to date 32.46773624420166s

------3 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda r, c: (2 * base[r][c] * (1 - base[r][c] // 16) - 32) if base[r][c] >= 16 else (2 * base[r][c] * base[r][c] // 32), range(len(base)), range(len(base[0])))

Total time to date 39.033531188964844s

------4 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r: vec_map(
            lambda c: ite(
                base[r][c] >= 16,
                2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32 + 1),
                2 * base[r][c] * (base[r][c] // 16)
            ),
            range(len(base[0]))
        ),
        range(len(base))
    )

Total time to date 46.681875228881836s

------5 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [
        vec_map(lambda col: 2 * base[row][col] *
                (1 - (base[row][col] // 16 if base[row][col] >= 16 else 0)) - 32 if base[row][col] >= 16 else base[row][col] * base[row][col] // 32, range(len(base[0])))
        for row in range(len(base))
    ]

Total time to date 52.947988986968994s

------6 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: miners_silicon_map(base[r][c], 16),
        base,
        [None for _ in range(len(base[0]))]
    )

def miners_silicon_map(base: int, limit: int) -> int:
    return 2 * base * (1 - (base // (limit if base >= limit else 16))) - 32 if base >= limit else base * base // 32

Total time to date 61.56970715522766s

------7 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda r, c: (2 * base[r][c] * (1 - min(1, base[r][c] // 16))) - 32 if base[r][c] >= 16 else (base[r][c] * base[r][c]) // 32, base)

Total time to date 69.97157621383667s

------8 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        if pixel >= 16:
            return 2 * pixel + pixel - 2 * (pixel // 32 + 1) - 32
        else:
            return 2 * pixel * (pixel // 16)

    return matrix_map(blend_pixel, base)

Total time to date 78.39008927345276s

------9 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32 + 1) - 32,
            reduce_mul([base[r][c], base[r][c]] // 16)
        ),
        base
    )

Total time to date 84.98146200180054s

------10 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda r, c: (base[r][c] / 12.92) if base[r][c] <= 0.04045 else ((base[r][c] + 0.055) / 1.055) ** 2.4 - 0.00031308, base)

Total time to date 92.7832841873169s

------11 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            (2 * base[r][c]) + base[r][c] - (2 * (base[r][c] // 16)) - 32,
            (2 * base[r][c]) * (base[r][c] // 16)
        ),
        base
    )

Total time to date 100.37575817108154s

------12 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        if pixel >= 16:
            return 2 * (pixel - (pixel // 32 + 1)) - 32
        else:
            return pixel * pixel // 16

    return [[blend_pixel(pixel) for pixel in row] for row in base]

Total time to date 109.72590517997742s

------13 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[
        2 * (v if v < 16 else v * (v // 32)) - 32 if v >= 16 else v * (v // 16)
        for v in row
    ] for row in base]

Total time to date 116.75983619689941s

------14 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [
        [
            2 * (base[row][col] - base[row][col] // 16) - 32 if base[row][col] >= 16 else base[row][col] * base[row][col] // 32
            for col in range(len(base[0]))
        ]
        for row in range(len(base))
    ]

Total time to date 127.30405616760254s

------15 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            2 * base[r][c] * (2 * base[r][c] // 32 + 1) - 32,
            2 * base[r][c] * (base[r][c] // 16)
        ),
        base
    )

Total time to date 133.93275213241577s

------16 solution---------
{
  "code": "def overlay_blend_8(base, active):\n    return [[2 * (v if v < 16 else v * (v // 32)) - 32 if v >= 16 else v * (v // 16) for v in row] for row in base]\n"
}

Total time to date 139.53690814971924s

------17 solution---------
def blend_pixel(base: int) -> int:
    if base >= 16:
        return 2 * (base - (base // 32 + 1)) - 32
    else:
        return base * base // 16



def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(blend_pixel, base)

Total time to date 147.99439215660095s

------18 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda r, c: (2 * base[r][c]) * (1 - base[r][c] // 16) - 32 if base[r][c] >= 16 else (2 * base[r][c]) * (base[r][c] // 32), base)

Total time to date 156.1781051158905s

------19 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(base: int) -> int:
        if base < 16: return base * (base // 16)
        return 2 * base * (base // 32) - 32

    return [[blend_pixel(base[row][col]) for col in range(len(base[0]))] for row in range(len(base))]



def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    if not base: return []
    blended_row = (blend_pixel(base[0][col]) for col in range(len(base[0])))
    return [blended_row] + overlay_blend_8(base[1:], active[1:])

Total time to date 167.3810260295868s

------20 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: (2 * base[r][c]) * (1 - min(1, base[r][c] // 16)) - 32 if base[r][c] >= 16 else (base[r][c]) * (base[r][c] // 16),
        base
    )

Total time to date 174.7516610622406s

------21 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [
        [
            2 * (v - (v // 32 if v >= 16 else 0)) - 32 if v >= 16
            else v * (v // 16)
            for v in row
        ]
        for row in base
    ]

Total time to date 182.46464109420776s

------22 solution---------
def overlay_blend_8(base, active):
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32),
            2 * base[r][c] * (base[r][c] // 32)
        ),
        base
    )

Total time to date 191.88803720474243s

------23 solution---------
def overlay_blend_8(base, active):
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            (2 * base[r][c]) * (base[r][c] // 16) - 32,
            (2 * base[r][c]) * (base[r][c] // 16)
        ),
        base
    )

Total time to date 200.0211741924286s

------24 solution---------
from functools import reduce
from typing import List

def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [
        [
            reduce(
                lambda p, n: 2 * p * (1 - n // 16) - 32 if p >= 16 else p * p // 32,
                col,
                base[row][col]
            )
            for col in range(len(base[0]))
        ]
        for row in range(len(base))
    ]

Total time to date 212.23645424842834s

------25 solution---------
def overlay_blend_8(base, active):
    return [[(2 * (v if v < 16 else v * (v // 32))) - 32 if v >= 16 else v * (v // 16) for v in row] for row in map(list, zip(*base))]

Total time to date 219.93936109542847s

------26 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    m, n = len(base), len(base[0])
    blended = [[0 for _ in range(n)] for _ in range(m)]

    for row in range(m):
        for col in range(n):
            blended[row][col] = max(2 * base[row][col] * (base[row][col] ** 0.5) // 32 - 32, 0)

    return blended

Total time to date 228.1702823638916s

------27 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_func(x: int) -> int:
        if x >= 16:
            return 2 * (x - 2 * (x // 32)) - 32
        else:
            return x * (x // 16)
    return matrix_map(blend_func, base)

Total time to date 236.8710162639618s

------28 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        if pixel >= 16:
            return 2 * (pixel - (pixel // 32 + 1)) - 32
        else:
            return pixel * pixel // 16

    return matrix_map(blend_pixel, base)

Total time to date 245.59485721588135s

------29 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            2 * base[r][c] * (base[r][c] // 32 - 1) - 32,
            base[r][c] * (base[r][c] // 8)
        ),
        base
    )

Total time to date 254.60059714317322s

------30 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        if pixel < 16:
            return (pixel * pixel) // 16
        else:
            return 2 * pixel * (pixel // 32) - 32

    return matrix_map(blend_pixel, base)

Total time to date 263.24978017807007s

------31 solution---------
def overlay_blend_8(base, active):
    def blend_pixel(base):
        return 2 * base * (1 - base // 16) - 32 if base >= 16 else base * base // 32

    return matrix_map(blend_pixel, base)

Total time to date 270.2361071109772s

------32 solution---------
overlay_blend_8 = lambda b, a: matrix_map(lambda r, c: int((2 * (c + c - (c // 16 if c >= 16 else 0) - 32) if c >= 16 else (c * c) // 16), base=b, active=a)

Total time to date 277.94711327552795s

------33 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(lambda r, c: ite(
        base[r][c] >= 16,
        2 * base[r][c] - (2 * (base[r][c] // 32) + 1) - 32,
        (2 * base[r][c]) * (base[r][c] // 16)
    ), base)

Total time to date 287.25020718574524s

------34 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: (2 * base[r][c] * (base[r][c] // 16)) - 32 if base[r][c] >= 16 else (2 * base[r][c] * base[r][c] // 32),
        base
    )

Total time to date 297.56273102760315s

------35 solution---------I understand, I will generate a different version of the program.
Total time to date 302.0673682689667s

------36 solution---------
def overlay_blend_8(base, active):
    return matrix_map(
        lambda r, c: (2 * base[r][c] * (base[r][c] // 16)) - 32 if base[r][c] >= 16 else (2 * base[r][c] * base[r][c] // 32),
        base
    )

Total time to date 309.8159999847412s

------37 solution---------
def overlay_blend_8(base, active):
    return [[max(0, (2 * v) * (v // 16) - 32) if v >= 16 else v * (v // 16) for v in row] for row in base]

Total time to date 316.5632312297821s

------38 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            2 * base[r][c] * (2 * base[r][c] // 32 + 1 - base[r][c] // 16) - 32,
            2 * base[r][c] * (base[r][c] // 16)
        ),
        base
    )

Total time to date 328.7964491844177s

------39 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            vec_scalar_mul(2, vector_scalar_add(base[r][c], base[r][c])) - vec_scalar_mul(2, integer_sqrt(base[r][c])) - 32,
            vec_scalar_mul(2, integer_sqrt(base[r][c]))
        ),
        base
    )

Total time to date 338.6649241447449s

------40 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        """Blend a single pixel, applying the overlay blend 8 algorithm."""
        if pixel >= 16:
            return 2 * pixel - (2 * (pixel // 32)) - 32
        else:
            return pixel * pixel // 16

    def blend_row(row: List[int]) -> List[int]:
        """Blend a single row of pixels, applying the 'blend_pixel' function to each pixel."""
        return [blend_pixel(pixel) for pixel in row]

    def blend_matrix(matrix: List[List[int]]) -> List[List[int]]:
        """Blend a matrix of pixels, applying the 'blend_row' function to each row."""
        if not matrix:
            return []
        else:
            return [blend_row(matrix[0])] + blend_matrix(matrix[1:])

    return blend_matrix(base)

Total time to date 351.2356472015381s

------41 solution---------
def overlay_blend_8(base: List[List[int]], _: List[List[int]]) -> List[List[int]]:
    return [[ite(base[row][col] >= 16, 2 * base[row][col] + base[row][col] - 2 * (base[row][col] // 32) - 32, 2 * base[row][col] * (base[row][col] // 16)) for col in range(len(base[0]))] for row in range(len(base))]

Total time to date 360.7762801647186s

------42 solution---------
from typing import List

def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    # Create a matrix of the same size filled with 16
    mask = [[16] * len(base[0]) for _ in range(len(base))]

    # Blend operation using matrix multiplication and scalar addition
    blended = matrix_elemwise_mul(base, reduce_vec(2)) + matrix_elemwise_div(mask, matrix_elemwise_mul(reduce_vec(32), reduce_vec(2)))

    # Apply the overlay blend 8 formula only for pixels >= 16
    blended = matrix_where(blended, blended, lambda x, y: ite(x >= 16, y, x))

    # Apply the final overlay blend 8 formula
    blended = matrix_map(lambda x: ite(x >= 16, 2 * x + x - 2 * (x // 32) - 32, 2 * x * x // 16), blended)

    return blended

Total time to date 371.58561611175537s

------43 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(base: int) -> int:
        return 2 * (base - (base >> 2) - 32) if base >= 16 else (base * base) >> 8

    return matrix_map(blend_pixel, base)

Total time to date 382.80014729499817s

------44 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[2 * v * (1 - v // 16) - 32 if v >= 16 else v * v // 16 for v in row] for row in base]

Total time to date 391.9787902832031s

------45 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        if pixel >= 16:
            return 2 * pixel + pixel - 2 * (pixel // 32 + 1) - 32
        else:
            return pixel * pixel // 16

    return matrix_map(blend_pixel, base)

Total time to date 402.9718132019043s

------46 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(
        lambda r, c: ite(
            base[r][c] >= 16,
            2 * base[r][c] + base[r][c] - 2 * (base[r][c] // 32) - 32,
            (2 * base[r][c]) * (base[r][c] // 16)
        ),
        base
    )

Total time to date 413.9239852428436s

------47 solution---------
from typing import List

# Given functions
def vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:
    ...

def matrix_map(map_int_to_int: Callable[[int], int], matrix_x: List[List[int]]) -> List[List[int]]:
    ...

def ite(cond: bool, a: int, b: int) -> int:
    ...

# Helper functions
def blend_pixel(pixel: int) -> int:
    if pixel < 16:
        return pixel * pixel // 16
    else:
        return 2 * pixel + pixel * (2 * pixel // 32) - 32

# Main function
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_map(blend_pixel, base)

Total time to date 425.7113530635834s

------48 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    def blend_pixel(pixel: int) -> int:
        if pixel < 16:
            return 2 * pixel * (pixel // 16)
        else:
            return 2 * pixel - (2 * (pixel // 32)) - 32

    return [[blend_pixel(p) for p in row] for row in base]

Total time to date 434.69882321357727s

------49 solution---------
def overlay_blend_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return [[(base[row][col] - 32) * (2 * (base[row][col] // 32 + 1) - 1) if base[row][col] >= 16 else (2 * base[row][col] ** 2 // 16) for col in range(len(base[0]))] for row in range(len(base))]

Total time to date 446.1367561817169s
