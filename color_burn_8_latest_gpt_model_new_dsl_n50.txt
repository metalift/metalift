--------------------------
Running benchmark color_burn_8 in suite blend
> /Users/jieq/Desktop/metalift/tenspiler/llm/scripts/run_with_parser_and_fuzzer_feedback.py(172)get_solution_from_gpt()
-> outputs = openai_client.chat.completions.create(
(Pdb) {'role': 'user', 'content': "\n    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function. Please generate the shortest possible solution.\n\n    #Instructions\n    # 1. Do not use for/while loops for rewriting the function.\n    # 2. The rewritten program should just be a single return statement of the form return provided_function(...)\n    # 3. Inline all the expressions. Do not use intermediate variables. Return the function signature as well as the function body in python.\n\n    #defined functions\n    ```python\n    from typing import Callable, List\n\n\ndef matrix_scalar_sub(matrix_x: List[List[int]], a: int) -> List[List[int]]:\n    # Subtract a scalar 'a' from each element of the matrix.\n    # matrix_x[i][j] = matrix_x[i][j] - a\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_sub(matrix_x[0], a), *matrix_scalar_sub(matrix_x[1:], a)]\n    )\n\n\ndef matrix_scalar_mul(matrix_x: List[List[int]], a: int) -> List[List[int]]:\n    # Multiply each element of the matrix by scalar 'a'.\n    # matrix_x[i][j] = matrix_x[i][j] * a\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_mul(matrix_x[0], a), *matrix_scalar_mul(matrix_x[1:], a)]\n    )\n\n\ndef matrix_scalar_div(matrix_x: List[List[int]], a: int) -> List[List[int]]:\n    # Divide each element of the matrix by scalar 'a' using integer division.\n    # matrix_x[i][j] = matrix_x[i][j] // a\n    return (\n        []\n        if len(matrix_x) < 1\n        else [vec_scalar_div(matrix_x[0], a), *matrix_scalar_div(matrix_x[1:], a)]\n    )\n\n\ndef scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    # Subtract each element of the matrix from scalar 'a'.\n    # matrix_x[i][j] = a - matrix_x[i][j]\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]\n    )\n\n\ndef scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:\n    # Divide scalar 'a' by each element of the matrix using integer division.\n    # matrix_x[i][j] = a // matrix_x[i][j]\n    return (\n        []\n        if len(matrix_x) < 1\n        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]\n    )\n\n\ndef vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:\n    # Apply a mapping function to each element in a vector.\n    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]\n\n\ndef matrix_where(\n    matrix_x: List[List[int]],\n    matrix_y: List[List[int]],\n    condition: Callable[[int, int], int],\n) -> List[List[int]]:\n    # Apply a conditional function element-wise between two matrices.\n    return (\n        []\n        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)\n        else [\n            vector_where(matrix_x[0], matrix_y[0], condition),\n            *matrix_where(matrix_x[1:], matrix_y[1:], condition),\n        ]\n    )\n\n\ndef vector_where(\n    x: List[int], y: List[int], condition: Callable[[int, int], int]\n) -> List[int]:\n    # Apply a conditional function element-wise between two vectors.\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [\n            condition(x[0], y[0]),\n            *vector_where(x[1:], y[1:], condition),\n        ]\n    )\n\n\ndef vec_slice(lst: List[int], start: int, end: int) -> List[int]:\n    # Slice a vector from index 'start' to 'end'.\n    return lst[:end][start:]\n\n\ndef matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    # Slice rows of a matrix from index 'start' to 'end'.\n    return matrix[:end][start:]\n\n\ndef matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:\n    # Slice columns of a matrix from index 'start' to 'end'.\n    return (\n        []\n        if len(matrix) < 1 or len(matrix[0][start:end]) < 1\n        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]\n    )\n\n\ndef firsts(matrix: List[List[int]]) -> List[int]:\n    # Helper function to extract the first element of each row in a matrix.\n    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]\n\n\ndef rests(matrix: List[List[int]]) -> List[List[int]]:\n    # Helper function to extract the rest of the elements in each row in a matrix.\n    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))\n\n\ndef matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:\n    # Transpose a matrix.\n    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]\n\n\ndef integer_exp(n: int) -> int:\n    # Compute the e^n as an integer.\n    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)\n\n\ndef reduce_max(x: List[int]) -> int:\n    # Find the maximum element in a vector.\n    return (\n        x[0]\n        if len(x) <= 1\n        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))\n    )\n\n\ndef vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:\n    # Element-wise multiplication of two vectors.\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]\n    )\n\n\ndef matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:\n    # Matrix-vector multiplication.\n    return (\n        []\n        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)\n        else [\n            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),\n            *matrix_vec_mul(matrix_x[1:], x),\n        ]\n    )\n\n\ndef vec_scalar_sub(x: List[int], a: int) -> List[int]:\n    # Subtract a scalar from each element in a vector.\n    # x[i] = x[i] - a\n    return [] if len(x) < 1 else [x[0] - a, *vec_scalar_sub(x[1:], a)]\n\n\ndef vec_scalar_mul(x: List[int], a: int) -> List[int]:\n    # Multiply a scalar with each element in a vector.\n    # x[i] = x[i] * a\n    return [] if len(x) < 1 else [x[0] * a, *vec_scalar_mul(x[1:], a)]\n\n\ndef vec_scalar_div(x: List[int], a: int) -> List[int]:\n    # Divide each element of the vector by scalar 'a' using integer division.\n    # x[i] = x[i] // a\n    return [] if len(x) < 1 else [x[0] // a, *vec_scalar_div(x[1:], a)]\n\n\ndef scalar_vec_sub(a: int, x: List[int]) -> List[int]:\n    # Subtract each element of the vector from scalar 'a'.\n    # x[i] = a - x[i]\n    return [] if len(x) < 1 else [a - x[0], *scalar_vec_sub(a, x[1:])]\n\n\ndef scalar_vec_div(a: int, x: List[int]) -> List[int]:\n    # Divide scalar 'a' by each element of the vector using integer division.\n    # x[i] = a // x[i]\n    return [] if len(x) < 1 else [a // x[0], *scalar_vec_div(a, x[1:])]\n\n\ndef vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:\n    # Perform element-wise addition between two vectors.\n    # z[i] = x[i] + y[i]\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:\n    # Perform element-wise subtraction between two vectors.\n    # z[i] = x[i] - y[i]\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]\n    )\n\n\ndef vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:\n    # Perform element-wise division between two vectors.\n    # z[i] = x[i] // y[i]\n    return (\n        []\n        if len(x) < 1 or not len(x) == len(y)\n        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]\n    )\n\n\ndef matrix_elemwise_add(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    # Perform element-wise addition between two matrices.\n    # z[i][j] = x[i][j] + y[i][j]\n    return (\n        []\n        if len(matrix_x) < 1\n        or not len(matrix_x) == len(matrix_y)\n        or vec_elemwise_add(matrix_x[0], matrix_y[0]) == []\n        else [\n            vec_elemwise_add(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_sub(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    # Perform element-wise subtraction between two matrices.\n    # z[i][j] = x[i][j] - y[i][j]\n    return (\n        []\n        if len(matrix_x) < 1\n        or not len(matrix_x) == len(matrix_y)\n        or vec_elemwise_sub(matrix_x[0], matrix_y[0]) == []\n        else [\n            vec_elemwise_sub(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_mul(x: List[int]) -> int:\n    # Multiply all elements in a vector.\n    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])\n\n\ndef matrix_elemwise_mul(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    # Perform element-wise multiplication between two matrices.\n    # z[i][j] = x[i][j] * y[i][j]\n    return (\n        []\n        if len(matrix_x) < 1\n        or not len(matrix_x) == len(matrix_y)\n        or vec_elemwise_mul(matrix_x[0], matrix_y[0]) == []\n        else [\n            vec_elemwise_mul(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef matrix_elemwise_div(\n    matrix_x: List[List[int]], matrix_y: List[List[int]]\n) -> List[List[int]]:\n    # Perform element-wise division between two matrices.\n    # z[i][j] = x[i][j] // y[i][j]\n    return (\n        []\n        if len(matrix_x) < 1\n        or not len(matrix_x) == len(matrix_y)\n        or vec_elemwise_div(matrix_x[0], matrix_y[0]) == []\n        else [\n            vec_elemwise_div(matrix_x[0], matrix_y[0]),\n            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),\n        ]\n    )\n\n\ndef reduce_sum(x: List[int]) -> int:\n    # Sum all elements in a vector.\n    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])\n\n\ndef integer_sqrt(n: int) -> int:\n    # Compute the integer square root of a number.\n    return n\n\n\ndef ite(cond: bool, a: int, b: int) -> int:\n    # Returns a if cond is True, otherwise b.\n    return a if cond else b\n\n\ndef col_vec(matrix: List[List[int]], col_index: int) -> List[int]:\n    # Extract a column vector from a matrix at index `col_index`.\n    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]\n    ```\n\n    ```cpp\n    //test function\n    #include <vector>\nusing namespace std;\n\nvector<vector<int>> color_burn_8(vector<vector<int>> base, vector<vector<int>> active)\n{\n    vector<vector<int>> out;\n    int m = base.size();\n    int n = base[0].size();\n\tfor (int row = 0; row < m; row++) {\n        vector<int> row_vec;\n\t\tfor (int col = 0; col < n; col++) {\n            int pixel;\n            if (active[row][col] == 0)\n                pixel = 32;\n            else\n                pixel = 32 - (32 - base[row][col]) / active[row][col];\n            row_vec.push_back(pixel);\n\t\t}\n\t\tout.push_back(row_vec);\n\t}\n\treturn out;\n}\n\n    ```\n    "}
(Pdb)
    Your task is to rewrite the given `test` C++ Function. You need to use only the set of provided functions and constants to achieve this. The rewritten program should be semantically equivalent to the `test` function. Please generate the shortest possible solution.

    #Instructions
    # 1. Do not use for/while loops for rewriting the function.
    # 2. The rewritten program should just be a single return statement of the form return provided_function(...)
    # 3. Inline all the expressions. Do not use intermediate variables. Return the function signature as well as the function body in python.

    #defined functions
    ```python
    from typing import Callable, List


def matrix_scalar_sub(matrix_x: List[List[int]], a: int) -> List[List[int]]:
    # Subtract a scalar 'a' from each element of the matrix.
    # matrix_x[i][j] = matrix_x[i][j] - a
    return (
        []
        if len(matrix_x) < 1
        else [vec_scalar_sub(matrix_x[0], a), *matrix_scalar_sub(matrix_x[1:], a)]
    )


def matrix_scalar_mul(matrix_x: List[List[int]], a: int) -> List[List[int]]:
    # Multiply each element of the matrix by scalar 'a'.
    # matrix_x[i][j] = matrix_x[i][j] * a
    return (
        []
        if len(matrix_x) < 1
        else [vec_scalar_mul(matrix_x[0], a), *matrix_scalar_mul(matrix_x[1:], a)]
    )


def matrix_scalar_div(matrix_x: List[List[int]], a: int) -> List[List[int]]:
    # Divide each element of the matrix by scalar 'a' using integer division.
    # matrix_x[i][j] = matrix_x[i][j] // a
    return (
        []
        if len(matrix_x) < 1
        else [vec_scalar_div(matrix_x[0], a), *matrix_scalar_div(matrix_x[1:], a)]
    )


def scalar_matrix_sub(a: int, matrix_x: List[List[int]]) -> List[List[int]]:
    # Subtract each element of the matrix from scalar 'a'.
    # matrix_x[i][j] = a - matrix_x[i][j]
    return (
        []
        if len(matrix_x) < 1
        else [scalar_vec_sub(a, matrix_x[0]), *scalar_matrix_sub(a, matrix_x[1:])]
    )


def scalar_matrix_div(a: int, matrix_x: List[List[int]]) -> List[List[int]]:
    # Divide scalar 'a' by each element of the matrix using integer division.
    # matrix_x[i][j] = a // matrix_x[i][j]
    return (
        []
        if len(matrix_x) < 1
        else [scalar_vec_div(a, matrix_x[0]), *scalar_matrix_div(a, matrix_x[1:])]
    )


def vec_map(x: List[int], map_int_to_int: Callable[[int], int]) -> List[int]:
    # Apply a mapping function to each element in a vector.
    return [] if len(x) < 1 else [map_int_to_int(x[0]), *vec_map(x[1:], map_int_to_int)]


def matrix_where(
    matrix_x: List[List[int]],
    matrix_y: List[List[int]],
    condition: Callable[[int, int], int],
) -> List[List[int]]:
    # Apply a conditional function element-wise between two matrices.
    return (
        []
        if len(matrix_x) < 1 or not len(matrix_x) == len(matrix_y)
        else [
            vector_where(matrix_x[0], matrix_y[0], condition),
            *matrix_where(matrix_x[1:], matrix_y[1:], condition),
        ]
    )


def vector_where(
    x: List[int], y: List[int], condition: Callable[[int, int], int]
) -> List[int]:
    # Apply a conditional function element-wise between two vectors.
    return (
        []
        if len(x) < 1 or not len(x) == len(y)
        else [
            condition(x[0], y[0]),
            *vector_where(x[1:], y[1:], condition),
        ]
    )


def vec_slice(lst: List[int], start: int, end: int) -> List[int]:
    # Slice a vector from index 'start' to 'end'.
    return lst[:end][start:]


def matrix_row_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:
    # Slice rows of a matrix from index 'start' to 'end'.
    return matrix[:end][start:]


def matrix_col_slice(matrix: List[List[int]], start: int, end: int) -> List[List[int]]:
    # Slice columns of a matrix from index 'start' to 'end'.
    return (
        []
        if len(matrix) < 1 or len(matrix[0][start:end]) < 1
        else [matrix[0][start:end], *matrix_col_slice(matrix[1:], start, end)]
    )


def firsts(matrix: List[List[int]]) -> List[int]:
    # Helper function to extract the first element of each row in a matrix.
    return [] if len(matrix) < 1 else [matrix[0][0], *firsts(matrix[1:])]


def rests(matrix: List[List[int]]) -> List[List[int]]:
    # Helper function to extract the rest of the elements in each row in a matrix.
    return [] if len(matrix) < 1 else matrix_col_slice(matrix, 1, len(matrix[0]))


def matrix_transpose(matrix: List[List[int]]) -> List[List[int]]:
    # Transpose a matrix.
    return [] if len(matrix) < 1 else [firsts(matrix), *matrix_transpose(rests(matrix))]


def integer_exp(n: int) -> int:
    # Compute the e^n as an integer.
    return 1 if n <= 0 else (integer_exp((n - 1)) * 3 % 64)


def reduce_max(x: List[int]) -> int:
    # Find the maximum element in a vector.
    return (
        x[0]
        if len(x) <= 1
        else (x[0] if x[0] > reduce_max(x[1:]) else reduce_max(x[1:]))
    )


def vec_elemwise_mul(x: List[int], y: List[int]) -> List[int]:
    # Element-wise multiplication of two vectors.
    return (
        []
        if len(x) < 1 or not len(x) == len(y)
        else [x[0] * y[0], *vec_elemwise_mul(x[1:], y[1:])]
    )


def matrix_vec_mul(matrix_x: List[List[int]], x: List[int]) -> List[int]:
    # Matrix-vector multiplication.
    return (
        []
        if len(matrix_x) < 1 or len(matrix_x[0]) < 1 or not len(matrix_x[0]) == len(x)
        else [
            reduce_sum(vec_elemwise_mul(matrix_x[0], x)),
            *matrix_vec_mul(matrix_x[1:], x),
        ]
    )


def vec_scalar_sub(x: List[int], a: int) -> List[int]:
    # Subtract a scalar from each element in a vector.
    # x[i] = x[i] - a
    return [] if len(x) < 1 else [x[0] - a, *vec_scalar_sub(x[1:], a)]


def vec_scalar_mul(x: List[int], a: int) -> List[int]:
    # Multiply a scalar with each element in a vector.
    # x[i] = x[i] * a
    return [] if len(x) < 1 else [x[0] * a, *vec_scalar_mul(x[1:], a)]


def vec_scalar_div(x: List[int], a: int) -> List[int]:
    # Divide each element of the vector by scalar 'a' using integer division.
    # x[i] = x[i] // a
    return [] if len(x) < 1 else [x[0] // a, *vec_scalar_div(x[1:], a)]


def scalar_vec_sub(a: int, x: List[int]) -> List[int]:
    # Subtract each element of the vector from scalar 'a'.
    # x[i] = a - x[i]
    return [] if len(x) < 1 else [a - x[0], *scalar_vec_sub(a, x[1:])]


def scalar_vec_div(a: int, x: List[int]) -> List[int]:
    # Divide scalar 'a' by each element of the vector using integer division.
    # x[i] = a // x[i]
    return [] if len(x) < 1 else [a // x[0], *scalar_vec_div(a, x[1:])]


def vec_elemwise_add(x: List[int], y: List[int]) -> List[int]:
    # Perform element-wise addition between two vectors.
    # z[i] = x[i] + y[i]
    return (
        []
        if len(x) < 1 or not len(x) == len(y)
        else [x[0] + y[0], *vec_elemwise_add(x[1:], y[1:])]
    )


def vec_elemwise_sub(x: List[int], y: List[int]) -> List[int]:
    # Perform element-wise subtraction between two vectors.
    # z[i] = x[i] - y[i]
    return (
        []
        if len(x) < 1 or not len(x) == len(y)
        else [(x[0] - y[0]), *vec_elemwise_sub(x[1:], y[1:])]
    )


def vec_elemwise_div(x: List[int], y: List[int]) -> List[int]:
    # Perform element-wise division between two vectors.
    # z[i] = x[i] // y[i]
    return (
        []
        if len(x) < 1 or not len(x) == len(y)
        else [(x[0] // y[0]), *vec_elemwise_div(x[1:], y[1:])]
    )


def matrix_elemwise_add(
    matrix_x: List[List[int]], matrix_y: List[List[int]]
) -> List[List[int]]:
    # Perform element-wise addition between two matrices.
    # z[i][j] = x[i][j] + y[i][j]
    return (
        []
        if len(matrix_x) < 1
        or not len(matrix_x) == len(matrix_y)
        or vec_elemwise_add(matrix_x[0], matrix_y[0]) == []
        else [
            vec_elemwise_add(matrix_x[0], matrix_y[0]),
            *matrix_elemwise_add(matrix_x[1:], matrix_y[1:]),
        ]
    )


def matrix_elemwise_sub(
    matrix_x: List[List[int]], matrix_y: List[List[int]]
) -> List[List[int]]:
    # Perform element-wise subtraction between two matrices.
    # z[i][j] = x[i][j] - y[i][j]
    return (
        []
        if len(matrix_x) < 1
        or not len(matrix_x) == len(matrix_y)
        or vec_elemwise_sub(matrix_x[0], matrix_y[0]) == []
        else [
            vec_elemwise_sub(matrix_x[0], matrix_y[0]),
            *matrix_elemwise_sub(matrix_x[1:], matrix_y[1:]),
        ]
    )


def reduce_mul(x: List[int]) -> int:
    # Multiply all elements in a vector.
    return 1 if len(x) < 1 else x[0] * reduce_mul(x[1:])


def matrix_elemwise_mul(
    matrix_x: List[List[int]], matrix_y: List[List[int]]
) -> List[List[int]]:
    # Perform element-wise multiplication between two matrices.
    # z[i][j] = x[i][j] * y[i][j]
    return (
        []
        if len(matrix_x) < 1
        or not len(matrix_x) == len(matrix_y)
        or vec_elemwise_mul(matrix_x[0], matrix_y[0]) == []
        else [
            vec_elemwise_mul(matrix_x[0], matrix_y[0]),
            *matrix_elemwise_mul(matrix_x[1:], matrix_y[1:]),
        ]
    )


def matrix_elemwise_div(
    matrix_x: List[List[int]], matrix_y: List[List[int]]
) -> List[List[int]]:
    # Perform element-wise division between two matrices.
    # z[i][j] = x[i][j] // y[i][j]
    return (
        []
        if len(matrix_x) < 1
        or not len(matrix_x) == len(matrix_y)
        or vec_elemwise_div(matrix_x[0], matrix_y[0]) == []
        else [
            vec_elemwise_div(matrix_x[0], matrix_y[0]),
            *matrix_elemwise_div(matrix_x[1:], matrix_y[1:]),
        ]
    )


def reduce_sum(x: List[int]) -> int:
    # Sum all elements in a vector.
    return 0 if len(x) < 1 else x[0] + reduce_sum(x[1:])


def integer_sqrt(n: int) -> int:
    # Compute the integer square root of a number.
    return n


def ite(cond: bool, a: int, b: int) -> int:
    # Returns a if cond is True, otherwise b.
    return a if cond else b


def col_vec(matrix: List[List[int]], col_index: int) -> List[int]:
    # Extract a column vector from a matrix at index `col_index`.
    return matrix_transpose(matrix_col_slice(matrix, col_index, col_index + 1))[0]
    ```

    ```cpp
    //test function
    #include <vector>
using namespace std;

vector<vector<int>> color_burn_8(vector<vector<int>> base, vector<vector<int>> active)
{
    vector<vector<int>> out;
    int m = base.size();
    int n = base[0].size();
	for (int row = 0; row < m; row++) {
        vector<int> row_vec;
		for (int col = 0; col < n; col++) {
            int pixel;
            if (active[row][col] == 0)
                pixel = 32;
            else
                pixel = 32 - (32 - base[row][col]) / active[row][col];
            row_vec.push_back(pixel);
		}
		out.push_back(row_vec);
	}
	return out;
}

    ```

(Pdb) ===== Starting iteration 0 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([32] * len(base), base), active
            )
        ),
        lambda act, _: 32 if act == 0 else 0  # the condition will select the correct element
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 1 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, base, lambda a, b: 32 if a == 0 else 32 - (32 - b // a))

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 2 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            matrix_scalar_sub(
                32, matrix_elemwise_div(scalar_matrix_sub(32, base), active)
            ),
            scalar_matrix_sub(32, active),
        ),
        lambda a, b: 32 if a == 0 else b,
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_sub expects a list of lists of integers for the 0th argument but got integer
===== Starting iteration 3 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [[32] * len(base[0]) for _ in range(len(base))],
            matrix_elemwise_div(
                scalar_matrix_sub(32, base),
                active
            )
        ),
        lambda a, _: 32 if a == 0 else _
    )

Passing solution to the parser
Failed to pass the parser List comprehensions are not supported
===== Starting iteration 4 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [[32] * len(base[0])] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([[32] * len(base[0])] * len(base), base),
                active
            )
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 5 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_scalar_div(scalar_matrix_sub(32, base), active)
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 6 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [[32] * len(row) for row in base],
            matrix_scalar_div(scalar_matrix_sub(32, base), active)
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser List comprehensions are not supported
===== Starting iteration 7 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        scalar_matrix_sub(32, base),
        matrix_scalar_div(scalar_matrix_sub(32, base), active),
        lambda x, y: 32 if y == 0 else 32 - y
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_div expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 8 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        scalar_matrix_sub(32, matrix_elemwise_div(scalar_matrix_sub(32, base), active)),
        lambda a, b: 32 if a == 0 else b,
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 9 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(matrix_scalar_sub([32] * len(base), base), active),
        ),
        lambda a, b: 32 if a == 0 else b,
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 10 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_div(matrix_scalar_sub(matrix_scalar_sub(base, 32), 32), active), lambda a, b: 32 if a == 0 else 32 - b)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 11 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_sub(matrix_scalar_sub(matrix_scalar_sub(base, 32), 32), scalar_matrix_div(32, active)), lambda a, b: 32 if a == 0 else b)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 12 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32],
            matrix_elemwise_div(
                scalar_matrix_sub(32, base),
                active
            )
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 13 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_scalar_sub(
            matrix_scalar_div(
                matrix_scalar_sub(matrix_scalar_sub(base, 32), active),
                1
            ),
            32
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_sub expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 14 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        matrix_scalar_sub([[32] * len(base[0])] * len(base), matrix_scalar_div(scalar_matrix_sub(32, base), active)),
        [[32] * len(base[0])] * len(base),
        lambda a, b: b if a == 0 else a
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 15 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, scalar_matrix_sub(32, matrix_elemwise_div(scalar_matrix_sub(32, base), active)), lambda a, b: 32 if a == 0 else b)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 16 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base), matrix_elemwise_div(matrix_scalar_sub([32] * len(base), base), active)
        ),
        lambda a, _: 32 if a == 0 else None,
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 17 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base), matrix_elemwise_div(matrix_elemwise_sub([32] * len(base), base), active)
        ),
        lambda a, _: 32 if a == 0 else a
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 18 =====

if (active[row][col] == 0)
    pixel = 32;
else
    pixel = 32 - (32 - base[row][col]) / active[row][col];

Passing solution to the parser
Failed to pass the parser <string>:5: error: invalid syntax  [syntax]
===== Starting iteration 19 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_sub(matrix_scalar_sub([[32]*len(base[0])]*len(base), 32), matrix_scalar_div(matrix_scalar_sub([[32]*len(base[0])]*len(base), base), active)), lambda a, res: 32 if a == 0 else res)

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 20 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        scalar_matrix_sub(32, scalar_matrix_div(32, matrix_elemwise_sub(scalar_matrix_sub(32, base), active))),
        lambda a, _: 32 if a == 0 else _
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 21 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_scalar_sub(
            matrix_scalar_div(
                scalar_matrix_sub(32, base),
                active
            ),
            32
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_div expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 22 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_div(matrix_scalar_sub(matrix_scalar_sub(base, 32), active), 1), lambda a, b: 32 if a == 0 else 32 - b)

Passing solution to the parser
Failed to pass the parser matrix_scalar_sub expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 23 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_div(matrix_scalar_sub(base, 32), active), lambda a, b: 32 if a == 0 else 32 - b)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 24 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            matrix_scalar_sub(base, 32),
            matrix_elemwise_div(matrix_scalar_sub(base, 32), active)
        ),
        lambda a, b: 32 if a == 0 else 32 - b
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 25 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([32] * len(base), base),
                active
            )
        ),
        lambda x, _: 32 if x == 0 else _
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 26 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [[32] * len(base[0])] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([[32] * len(base[0])] * len(base), base),
                active
            )
        ),
        lambda a, _: 32 if a == 0 else 32 - (32 - base[0][0]) // a
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 27 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(
                matrix_scalar_sub([32] * len(base), base),
                active
            )
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 28 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_sub(matrix_scalar_sub([[32] * len(base[0])] * len(base), matrix_scalar_div(matrix_elemwise_sub([[32] * len(base[0])] * len(base), base), active)), lambda x, y: 32 if x == 0 else y)

Passing solution to the parser
Failed to pass the parser <string>:6: error: unexpected EOF while parsing  [syntax]
===== Starting iteration 29 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base), matrix_elemwise_div(scalar_matrix_sub(32, base), active)
        ),
        lambda a, _: 32 if a == 0 else _
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 30 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        base,
        lambda a, b: 32 if a == 0 else 32 - (32 - b) // a
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Correct
===== Starting iteration 31 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, scalar_matrix_sub(32, matrix_scalar_div(scalar_matrix_sub(32, base), active)), lambda a, _: 32 if a == 0 else _)

Passing solution to the parser
Failed to pass the parser matrix_scalar_div expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 32 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        scalar_matrix_sub(32, matrix_scalar_div(scalar_matrix_sub(32, base), active)),
        [[32] * len(base[0])] * len(base),
        lambda a, b: 32 if b == 0 else a
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_div expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 33 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        scalar_matrix_div(32, active),
        matrix_elemwise_sub(
            scalar_matrix_sub(32, base),
            matrix_elemwise_div(
                scalar_matrix_sub(32, base), active
            )
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 34 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_sub(matrix_scalar_sub([[32]*len(base[0])]*len(base), base), scalar_matrix_div(32, active)), lambda a, b: 32 if a == 0 else b)

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 35 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        scalar_matrix_sub(32, matrix_scalar_div(scalar_matrix_sub(32, base), active)),
        lambda a, _: 32 if a == 0 else _
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_div expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 36 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_scalar_sub(
            matrix_scalar_div(
                matrix_scalar_sub([[32] * len(base[0])] * len(base), 32),
                active
            ),
            32
        ),
        lambda a, b: 32 if a == 0 else 32 - b
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 37 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [[32] * len(base[0])] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([[32] * len(base[0])] * len(base), base),
                active
            )
        ),
        lambda a, _: 32 if a == 0 else a
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 38 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_scalar_div(matrix_scalar_sub([[32]*len(base[0])]*len(base), 32), active), lambda a, _: 32 if a == 0 else 32 - _)

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 39 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, scalar_matrix_sub(32, matrix_elemwise_div(scalar_matrix_sub(32, base), active)), lambda a, b: 32 if a == 0 else b)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 40 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_div(matrix_scalar_sub(matrix_scalar_sub(base, 32), 32), active), lambda a, _: 32 if a == 0 else 32 - _)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 41 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([32] * len(base), base), active
            )
        ),
        lambda a, _: 32 if a == 0 else 32 - (32 - base[0][0]) // a
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 42 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(active, matrix_elemwise_add(matrix_scalar_sub(matrix_scalar_sub(base, 32), 32), scalar_matrix_div(32, active)), lambda x, y: 32 if x == 0 else y)

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 43 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_elemwise_sub(
        [[32] * len(base[0]) for _ in base],
        matrix_where(
            active,
            matrix_scalar_div(
                matrix_scalar_sub([[32] * len(base[0]) for _ in base], base),
                active
            ),
            lambda a, _: 32 if a == 0 else _
        )
    )

Passing solution to the parser
Failed to pass the parser List comprehensions are not supported
===== Starting iteration 44 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(
                matrix_scalar_sub([32] * len(base), base),
                active
            )
        ),
        lambda a, _: 32 if a == 0 else _
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 45 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_div(
            matrix_scalar_sub(matrix_scalar_sub(base, 32), -32),
            active
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 46 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        scalar_matrix_div(32, active),
        matrix_scalar_sub(scalar_matrix_div(32, matrix_elemwise_sub(scalar_matrix_sub(32, base), active)), 32),
        lambda act, _: 32 if act == 0 else 32 - act
    )

Passing solution to the parser
Passed the parser
Running fuzzer tests
Skipping file /Users/jieq/Downloads/outputs_dexter_3/color_burn_8/color_burn_8_1_5180.json
Found failed test cases
Incorrect
===== Starting iteration 47 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_scalar_sub(scalar_matrix_div(32, active), matrix_scalar_sub(base, 32)),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser matrix_scalar_sub expects integer for the 1th argument but got a list of lists of integers
===== Starting iteration 48 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [32] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([32] * len(base), base),
                active
            )
        ),
        lambda act, _: 32 if act == 0 else _
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
===== Starting iteration 49 =====

def color_burn_8(base: List[List[int]], active: List[List[int]]) -> List[List[int]]:
    return matrix_where(
        active,
        matrix_elemwise_sub(
            [[32] * len(base[0])] * len(base),
            matrix_elemwise_div(
                matrix_elemwise_sub([[32] * len(base[0])] * len(base), base), active
            ),
        ),
        lambda a, b: 32 if a == 0 else b
    )

Passing solution to the parser
Failed to pass the parser Binary operation * is not supported on types builtins.list[builtins.list[builtins.int]] and builtins.int
